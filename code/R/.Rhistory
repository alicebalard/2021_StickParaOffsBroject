plotdf$residuals <- residuals(fit)
ggplot(plotdf, aes(x=Nbr_coveredCpG, y=Nbr_methCpG))+
geom_smooth(method = "lm", col="black")+
geom_segment(aes(xend = Nbr_coveredCpG, yend = predicted), col = "grey") +
geom_point(aes(col=trtG1G2), size = 3)+ scale_color_manual(values = colOffs) +
scale_x_continuous("Number of cytosines covered") +
scale_y_continuous("Number of methylated cytosines") +
theme_bw() + ggtitle(label = "Offspring, CpG shared by half fish/trt")
## Check after RMS correction for coverage bias: SEMI CORRECTED (p-value = 0.01, rho = -0.24)
cor.test(fullMetadata_OFFS$Nbr_coveredCpG,
fullMetadata_OFFS$RMS_coveredCpG, method = "spearman")
ggplot(fullMetadata_OFFS, aes(x=Nbr_coveredCpG, y=RMS_coveredCpG))+
geom_point(aes(col=trtG1G2), size = 3)+ scale_color_manual(values = colOffs) +
geom_smooth(method = "lm", col="black")+
theme_bw() + ggtitle(label = "Offspring, CpG shared by half fish/trt")
## and with residuals: COMPLETELY CORRECTED p-value = 0.51
cor.test(fullMetadata_OFFS$Nbr_coveredCpG,
fullMetadata_OFFS$res_Nbr_methCpG_Nbr_coveredCpG, method = "spearman")
ggplot(fullMetadata_OFFS, aes(x=Nbr_coveredCpG, y=res_Nbr_methCpG_Nbr_coveredCpG))+
geom_point(aes(col=trtG1G2), size = 3)+ scale_color_manual(values = colOffs) +
geom_smooth(method = "lm", col="black")+
scale_x_continuous("Number of cytosines covered") +
scale_y_continuous("Residuals of number of methylated cytosines\n on number of cytosines covered") +
theme_bw() + ggtitle(label = "Offspring, CpG shared by half fish/trt")
mod = lm(MappingEfficiency.BSBoldvsGynogen ~ Sex, data = fullMetadata_OFFS)
summary(step(mod))
plot(ggpredict(mod, terms = c("Sex")), add.data = T)
mod = lm(M.Seqs_rawReads ~ Sex, data = fullMetadata_OFFS)
summary(step(mod))
plot(ggpredict(mod, terms = c("Sex")), add.data = T)
mod = lm(MeanCoverage ~ Sex, data = fullMetadata_OFFS)
summary(step(mod))
plot(ggpredict(mod, terms = c("Sex")), add.data = T)
mod = lm(Nbr_coveredCpG ~ Sex, data = fullMetadata_OFFS)
summary(step(mod))
plot(ggpredict(mod, terms = c("Sex")), add.data = T)
mod = lm(OverallPercentageMethylation ~ Sex, data = fullMetadata_OFFS)
summary(step(mod))
plot(ggpredict(mod, terms = c("Sex")), add.data = T)
mod = lm(res_Nbr_methCpG_Nbr_coveredCpG ~ Sex, data = fullMetadata_OFFS)
summary(step(mod)) # sex is significant p = 0.000157 ***
plot(ggpredict(mod, terms = c("Sex")), add.data = T)
fullMetadata_OFFS$res_Nbr_methCpG_Nbr_coveredCpG_div1000 <- (fullMetadata_OFFS$res_Nbr_methCpG_Nbr_coveredCpG)/1000
mod_Tol.Meth <- lmer(BCI ~ res_Nbr_methCpG_Nbr_coveredCpG_div1000*No.Worms*PAT + (1|brotherPairID)+ (1|Sex),
data=fullMetadata_OFFS, REML = F)
## Model selection:
step(mod_Tol.Meth, reduce.random = F) # Model found: BCI ~ No.Worms + PAT + (1 | brotherPairID) + (1 | Sex) + No.Worms:PAT
## The slope of BCI on nbrworms varies upon treatment but methylation does NOT vary with tolerance
mod_Tol.Meth <- lmer(BCI ~ No.Worms*PAT + (1|brotherPairID)+ (1|Sex),
data=fullMetadata_OFFS)
plot(ggpredict(mod_Tol.Meth, terms = c("No.Worms", "PAT")), add.data=T)+ theme_bw() +
ylab("Body Condition Index") + xlab("Number of worms") +
ggtitle("Predicted values of Body Condition Index in offspring")+
scale_color_manual(NULL, values = c("black", "red")) +
scale_fill_manual(NULL, values = c("black", "red"))  +
geom_point(size=0)+ # to have color key in legend as point
guides(colour = guide_legend(override.aes = list(size=3,linetype=0, fill = NA)))
## And by treatment instead of No.worms?
mod_Tol.Meth2 <- lmer(BCI ~ res_Nbr_methCpG_Nbr_coveredCpG_div1000*PAT*outcome + (1|brotherPairID)+ (1|Sex),
data=fullMetadata_OFFS, REML = F)
plot(ggpredict(mod_Tol.Meth2, terms = c("res_Nbr_methCpG_Nbr_coveredCpG_div1000","PAT", "outcome")), add.data=T)+
scale_color_manual(values = colOffs)
## Model selection:
step(mod_Tol.Meth2, reduce.random = F) # Model found: BCI ~ PAT + outcome + (1 | brotherPairID) + (1 | Sex) + PAT:outcome
## The slope of BCI on nbrworms varies upon parental treatment = methylation does NOT vary with tolerance
## By group, tolerance slope as a function of methylation residuals:
modFULL <- lmer(BCI ~ res_Nbr_methCpG_Nbr_coveredCpG_div1000*No.Worms + (1|brotherPairID) + (1|Sex),
data = fullMetadata_OFFS[fullMetadata_OFFS$trtG1G2 %in% c("NE_exposed", "E_exposed"),])
## Model selection:
step(modFULL, reduce.random = F) # Model found: BCI ~ (1 | brotherPairID) + (1 | Sex)
modFULL <- lmer(BCI ~ res_Nbr_methCpG_Nbr_coveredCpG_div1000*PAT + (1|brotherPairID) + (1|Sex),
data = fullMetadata_OFFS[fullMetadata_OFFS$trtG1G2 %in% c("NE_exposed", "E_exposed"),])
## Model selection:
step(modFULL, reduce.random = F) # Model found: BCI ~ PAT + (1 | brotherPairID) + (1 | Sex)
plot(ggpredict(modFULL, terms = c("res_Nbr_methCpG_Nbr_coveredCpG_div1000", "PAT")))
# Set up scatterplot
scatterplot <- ggplot(fullMetadata_OFFS,
aes(x = res_Nbr_methCpG_Nbr_coveredCpG,
y = BCI, fill=trtG1G2)) +
geom_point(pch=21, size =3, alpha = .8) +
guides(color = "none") +
scale_fill_manual(values = colOffs, name = "Treatment",
labels = c("G1 control - G2 control", "G1 control - G2 exposed", "G1 exposed - G2 control", "G1 exposed - G2 exposed")) +
theme(plot.margin = margin()) + theme_bw() +
theme(legend.position = "none") +
xlab("Methylation residuals (methylated sites/coverage")+
ylab("Body Condition Index")
# Define marginal histogram
marginal_distribution <- function(x, var, group) {
ggplot(x, aes_string(x = var, fill = group)) +
# geom_histogram(bins = 30, alpha = 0.4, position = "identity") +
geom_density(alpha = 0.6, size = 0.2) +
guides(fill = "none") +
scale_fill_manual(values = colOffs) +
theme_void() +
theme(plot.margin = margin())
}
# Set up marginal histograms
x_hist <- marginal_distribution(fullMetadata_OFFS, "res_Nbr_methCpG_Nbr_coveredCpG", "trtG1G2")
y_hist <- marginal_distribution(fullMetadata_OFFS, "BCI", "trtG1G2") +
coord_flip()
# Align histograms with scatterplot
aligned_x_hist <- align_plots(x_hist, scatterplot, align = "v")[[1]]
aligned_y_hist <- align_plots(y_hist, scatterplot, align = "h")[[1]]
# Arrange plots
cowplot::plot_grid(
aligned_x_hist, NULL, scatterplot, aligned_y_hist, ncol = 2, nrow = 2, rel_heights = c(0.2, 1), rel_widths = c(1, 0.2)
)
# pdf("Rfigures/clusterALLCpG.pdf", width = 17, height = 8)
makePrettyMethCluster(uniteCovALL_woSexAndUnknowChr, fullMetadata,
my.cols.trt=c("#333333ff","#ff0000ff","#ffe680ff","#ff6600ff","#aaccffff","#aa00d4ff"),
my.cols.fam = c(1:4), nbrk = 8)
# dev.off()
#pdf("Rfigures/clusterALLCpG_offspings.pdf", width = 17, height = 8)
makePrettyMethCluster(uniteCovALL_G2_woSexAndUnknowChr, fullMetadata_OFFS,
my.cols.trt=c("#ffe680ff","#ff6600ff", "#aaccffff", "#aa00d4ff"),
my.cols.fam = c(1:4), nbrk = 8)
#dev.off()
#pdf("Rfigures/clusterALLCpG_offspings.pdf", width = 17, height = 8)
makePrettyMethCluster(uniteCovALL_G2_woSexAndUnknowChr, fullMetadata_OFFS,
my.cols.trt=c("#ffe680ff","#ff6600ff", "#aaccffff", "#aa00d4ff"),
my.cols.fam = c(1:4), nbrk = 8)
#dev.off()
# pdf("Rfigures/clusterALLCpG.pdf", width = 17, height = 8)
makePrettyMethCluster(uniteCovALL_woSexAndUnknowChr, fullMetadata,
my.cols.trt=c("#333333ff","#ff0000ff","#ffe680ff","#ff6600ff","#aaccffff","#aa00d4ff"),
my.cols.fam = c(1:4), nbrk = 8)
# dev.off()
makePrettyMethCluster(uniteCovALL_G2_woSexAndUnknowChr, fullMetadata_OFFS,
my.cols.trt=c("#ffe680ff","#ff6600ff", "#aaccffff", "#aa00d4ff"),
my.cols.fam = c(1:4), nbrk = 8)
makePrettyMethCluster(uniteCovALL_woSexAndUnknowChr, fullMetadata,
my.cols.trt=c("#333333ff","#ff0000ff","#ffe680ff","#ff6600ff","#aaccffff","#aa00d4ff"),
my.cols.fam = c(1:4), nbrk = 8)
# make distance matrix with B-C distances
data.dist = makeDatadistFUN(uniteCovALL_G2_woSexAndUnknowChr)
## Adonis test: importance of each predictor
adonis2(data.dist ~ PAT * outcome * Sex * brotherPairID, data = fullMetadata_OFFS)
perm <- how(nperm = 1000) # 1000 permutations
setBlocks(perm) <- with(fullMetadata_OFFS, brotherPairID) # define the permutation structure considering brotherPairID
## Full model
print(adonis2(data.dist ~ PAT * outcome * Sex, data = fullMetadata_OFFS, permutations = perm))
## remove the non significant interactions
print(adonis2(data.dist ~ PAT + outcome + Sex, data = fullMetadata_OFFS, permutations = perm))
perm <- how(nperm = 1000) # 1000 permutations
setBlocks(perm) <- with(fullMetadata_OFFS, brotherPairID) # define the permutation structure considering brotherPairID
## Full model
print(adonis2(data.dist ~ PAT * outcome * Sex, data = fullMetadata_OFFS, permutations = perm))
## remove the non significant interactions
print(adonis2(data.dist ~ PAT + outcome + Sex, data = fullMetadata_OFFS, permutations = perm))
## remove the non significant interactions
print(adonis2(data.dist ~ PAT + outcome + Sex + outcome:Sex + PAT:outcome:Sex, data = fullMetadata_OFFS, permutations = perm))
perm <- how(nperm = 1000) # 1000 permutations
setBlocks(perm) <- with(fullMetadata_OFFS, brotherPairID) # define the permutation structure considering brotherPairID
## Full model
print(adonis2(data.dist ~ PAT * outcome * Sex, data = fullMetadata_OFFS, permutations = perm))
## remove the non significant interactions
print(adonis2(data.dist ~ PAT + outcome + Sex + outcome:Sex + PAT:outcome:Sex, data = fullMetadata_OFFS, permutations = perm))
## Full model
print(adonis2(data.dist ~ PAT * outcome * Sex, data = fullMetadata_OFFS, permutations = perm))
fullMetadata_OFFS$brotherPairID
fullMetadata_OFFS$Sex
paste(fullMetadata_OFFS$brotherPairID, fullMetadata_OFFS$Sex)
table(paste(fullMetadata_OFFS$brotherPairID, fullMetadata_OFFS$Sex))
fullMetadata_OFFS$BP_Sex <- paste(fullMetadata_OFFS$brotherPairID, fullMetadata_OFFS$Sex)
perm <- how(nperm = 1000) # 1000 permutations
setBlocks(perm) <- with(fullMetadata_OFFS, BP_Sex) # define the permutation structure considering brotherPairID and sex
print(adonis2(data.dist ~ PAT * outcome, data = fullMetadata_OFFS, permutations = perm))
# make distance matrix with B-C distances
data.dist = makeDatadistFUN(uniteCovALL_G2_woSexAndUnknowChr)
data.dist
fullMetadata_OFFS$SampleID
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
machine="mythinkpad" # define the machine we work on
loadALL = TRUE # load all uniteCov objects
loadannot = TRUE # load genome annotations
sourceDMS = TRUE # Load the calculated DMS
sourceSubUnite = FALSE
source("R02.3_DATALOAD.R")
fullMetadata$SampleID
fullMetadata_OFFS$SampleID
fullMetadata_PAR$SampleID
fullMetadata_OFFS$BCI <- residuals(lmer(Wnettofin ~ Slfin * Sex + (1|brotherPairID), data=fullMetadata_OFFS))
## and for parents (no sex difference, only males):
fullMetadata_PAR$BCI <- residuals(lmer(Wnettofin ~ Slfin + (1|brotherPairID), data=fullMetadata_PAR))
fullMetadata_OFFS$SampleID
mod1 <- lme(BCI ~ offsTrt * patTrt, random=~1|brotherPairID,data=fullMetadata_OFFS)
anova(mod1) # strong significant effect of both offspring trt & paternal + interactions
mod1.2 <- lme(BCI ~  trtG1G2, random=~1|brotherPairID,data=fullMetadata_OFFS)
## pairwise posthoc test
emmeans(mod1.2, list(pairwise ~ trtG1G2), adjust = "tukey")
## Control father - treatment offspring has a strongly significantly lower BC than
## every other group, same as Kaufmann et al. 2014
myplot1 <- ggplot(fullMetadata_OFFS, aes(x=trtG1G2, y = BCI, fill=trtG1G2))+
geom_boxplot()+
geom_signif(comparisons = list(c("NE_control", "NE_exposed")),
map_signif_level=TRUE, annotations="***",
y_position = 150, tip_length = 0, vjust=0.4) +
geom_signif(comparisons = list(c("NE_exposed", "E_control")),
map_signif_level=TRUE, annotations="***",
y_position = 200, tip_length = 0, vjust=0.4) +
geom_signif(comparisons = list(c("NE_exposed", "E_exposed")),
map_signif_level=TRUE, annotations="***",
y_position = 250, tip_length = 0, vjust=0.4) +
scale_fill_manual(values = colOffs)+
theme_bw() + theme(legend.position = "none") +
ylab("Body Condition Index") +
scale_x_discrete(labels=c("NE_control" = "G1 control\nG2 control", "NE_exposed" = "G1 control\nG2 infected",
"E_control" = "G1 infected\nG2 control", "E_exposed" = "G1 infected\nG2 infected"),
name = NULL)
myplot1
mod_Tol <- lmer(BCI ~ No.Worms*PAT + (1|brotherPairID)+ (1|Sex), data=fullMetadata_OFFS, REML = F)
## Model selection:
step(mod_Tol, reduce.random = F) # Model found: full model
## The slope of BCI on nbrworms varies upon treatment
plot(ggpredict(mod_Tol, terms = c("No.Worms", "PAT")), add.data=T)+ theme_bw() +
ylab("Body Condition Index") + xlab("Number of worms") +
ggtitle("Predicted values of Body Condition Index in offspring")+
scale_color_manual(NULL, values = c("black", "red")) +
scale_fill_manual(NULL, values = c("black", "red"))  +
scale_x_continuous(breaks = 0:10)+
geom_point(size=0)+ # to have color key in legend as point
guides(colour = guide_legend(override.aes = list(size=3,linetype=0, fill = NA)))
mycalcRMS <- function(myUniteCov, myMetaData){
percMethMat = methylKit::percMethylation(myUniteCov)
# create a dataframe with all info
percMethDF = data.frame(SampleID = colnames(percMethMat),
Nbr_methCpG = colSums(percMethMat>=70 & !is.na(percMethMat)), ## number of methylated sites
Nbr_coveredCpG = colSums(!is.na(percMethMat)), ## number of sites covered in this sample
Nbr_NOTcoveredCpG = colSums(is.na(percMethMat)),## number of sites NOT covered in this sample
MeanCoverage = colMeans(methylKit::getData(myUniteCov)[,myUniteCov@coverage.index], na.rm = T), ## coverage.index: vector denoting which columns in the data correspond to coverage values
OverallPercentageMethylation = colMeans(methylKit::percMethylation(myUniteCov), na.rm = T))
## RMS in this sample based on covered sites
percMethDF$RMS_coveredCpG = percMethDF$Nbr_methCpG / percMethDF$Nbr_coveredCpG
## merge with original metadata:
myMetaData = merge(myMetaData, percMethDF)
# calculate also RMS global, considering CpG covered or not (to compare)
myMetaData$RMS_allCpG_coveredOrNot = myMetaData$Nbr_methCpG / (myMetaData$M.Seqs_rawReads*10e6)
# calculate residuals of nbr of methCpG by nbr of covered CpG
myMetaData$res_Nbr_methCpG_Nbr_coveredCpG = residuals(
lm(myMetaData$Nbr_methCpG ~ myMetaData$Nbr_coveredCpG))
return(myMetaData)
}
fullMetadata <- mycalcRMS(uniteCovALL_woSexAndUnknowChr, fullMetadata)
fullMetadata <- mycalcRMS(uniteCovALL_woSexAndUnknowChr, fullMetadata)
fullMetadata_PAR_2 <- mycalcRMS(uniteCov6_G1_woSexAndUnknowChrOVERLAP, fullMetadata_PAR)
fullMetadata_PAR_2 <- mycalcRMS(uniteCov6_G1_woSexAndUnknowChrOVERLAP, fullMetadata_PAR)
fullMetadata_OFFS_2  <- mycalcRMS(uniteCov14_G2_woSexAndUnknowChrOVERLAP, fullMetadata_OFFS)
fullMetadata_OFFS_2$SampleID
mycalcRMS <- function(myUniteCov, myMetaData){
percMethMat = methylKit::percMethylation(myUniteCov)
# create a dataframe with all info
percMethDF = data.frame(SampleID = colnames(percMethMat),
Nbr_methCpG = colSums(percMethMat>=70 & !is.na(percMethMat)), ## number of methylated sites
Nbr_coveredCpG = colSums(!is.na(percMethMat)), ## number of sites covered in this sample
Nbr_NOTcoveredCpG = colSums(is.na(percMethMat)),## number of sites NOT covered in this sample
MeanCoverage = colMeans(methylKit::getData(myUniteCov)[,myUniteCov@coverage.index], na.rm = T), ## coverage.index: vector denoting which columns in the data correspond to coverage values
OverallPercentageMethylation = colMeans(methylKit::percMethylation(myUniteCov), na.rm = T))
## RMS in this sample based on covered sites
percMethDF$RMS_coveredCpG = percMethDF$Nbr_methCpG / percMethDF$Nbr_coveredCpG
## merge with original metadata:
myMetaData = merge(myMetaData, percMethDF)
# calculate also RMS global, considering CpG covered or not (to compare)
myMetaData$RMS_allCpG_coveredOrNot = myMetaData$Nbr_methCpG / (myMetaData$M.Seqs_rawReads*10e6)
# calculate residuals of nbr of methCpG by nbr of covered CpG
myMetaData$res_Nbr_methCpG_Nbr_coveredCpG = residuals(
lm(myMetaData$Nbr_methCpG ~ myMetaData$Nbr_coveredCpG))
## REORDER myMetaData by sample ID
myMetaData = myMetaData[order(as.numeric(gsub("S", "", myMetaData$SampleID))),]
return(myMetaData)
}
fullMetadata_PAR_2 <- mycalcRMS(uniteCov6_G1_woSexAndUnknowChrOVERLAP, fullMetadata_PAR)
fullMetadata_PAR_2$SampleID
fullMetadata_OFFS_2  <- mycalcRMS(uniteCov14_G2_woSexAndUnknowChrOVERLAP, fullMetadata_OFFS)
fullMetadata_OFFS_2$SampleID
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
machine="mythinkpad" # define the machine we work on
loadALL = TRUE # load all uniteCov objects
loadannot = TRUE # load genome annotations
sourceDMS = TRUE # Load the calculated DMS
sourceSubUnite = FALSE
source("R02.3_DATALOAD.R")
fullMetadata_OFFS$BCI <- residuals(lmer(Wnettofin ~ Slfin * Sex + (1|brotherPairID), data=fullMetadata_OFFS))
## and for parents (no sex difference, only males):
fullMetadata_PAR$BCI <- residuals(lmer(Wnettofin ~ Slfin + (1|brotherPairID), data=fullMetadata_PAR))
mod1 <- lme(BCI ~ offsTrt * patTrt, random=~1|brotherPairID,data=fullMetadata_OFFS)
anova(mod1) # strong significant effect of both offspring trt & paternal + interactions
mod1.2 <- lme(BCI ~  trtG1G2, random=~1|brotherPairID,data=fullMetadata_OFFS)
## pairwise posthoc test
emmeans(mod1.2, list(pairwise ~ trtG1G2), adjust = "tukey")
## Control father - treatment offspring has a strongly significantly lower BC than
## every other group, same as Kaufmann et al. 2014
myplot1 <- ggplot(fullMetadata_OFFS, aes(x=trtG1G2, y = BCI, fill=trtG1G2))+
geom_boxplot()+
geom_signif(comparisons = list(c("NE_control", "NE_exposed")),
map_signif_level=TRUE, annotations="***",
y_position = 150, tip_length = 0, vjust=0.4) +
geom_signif(comparisons = list(c("NE_exposed", "E_control")),
map_signif_level=TRUE, annotations="***",
y_position = 200, tip_length = 0, vjust=0.4) +
geom_signif(comparisons = list(c("NE_exposed", "E_exposed")),
map_signif_level=TRUE, annotations="***",
y_position = 250, tip_length = 0, vjust=0.4) +
scale_fill_manual(values = colOffs)+
theme_bw() + theme(legend.position = "none") +
ylab("Body Condition Index") +
scale_x_discrete(labels=c("NE_control" = "G1 control\nG2 control", "NE_exposed" = "G1 control\nG2 infected",
"E_control" = "G1 infected\nG2 control", "E_exposed" = "G1 infected\nG2 infected"),
name = NULL)
myplot1
mod_Tol <- lmer(BCI ~ No.Worms*PAT + (1|brotherPairID)+ (1|Sex), data=fullMetadata_OFFS, REML = F)
## Model selection:
step(mod_Tol, reduce.random = F) # Model found: full model
## The slope of BCI on nbrworms varies upon treatment
plot(ggpredict(mod_Tol, terms = c("No.Worms", "PAT")), add.data=T)+ theme_bw() +
ylab("Body Condition Index") + xlab("Number of worms") +
ggtitle("Predicted values of Body Condition Index in offspring")+
scale_color_manual(NULL, values = c("black", "red")) +
scale_fill_manual(NULL, values = c("black", "red"))  +
scale_x_continuous(breaks = 0:10)+
geom_point(size=0)+ # to have color key in legend as point
guides(colour = guide_legend(override.aes = list(size=3,linetype=0, fill = NA)))
mycalcRMS <- function(myUniteCov, myMetaData){
percMethMat = methylKit::percMethylation(myUniteCov)
# create a dataframe with all info
percMethDF = data.frame(SampleID = colnames(percMethMat),
Nbr_methCpG = colSums(percMethMat>=70 & !is.na(percMethMat)), ## number of methylated sites
Nbr_coveredCpG = colSums(!is.na(percMethMat)), ## number of sites covered in this sample
Nbr_NOTcoveredCpG = colSums(is.na(percMethMat)),## number of sites NOT covered in this sample
MeanCoverage = colMeans(methylKit::getData(myUniteCov)[,myUniteCov@coverage.index], na.rm = T), ## coverage.index: vector denoting which columns in the data correspond to coverage values
OverallPercentageMethylation = colMeans(methylKit::percMethylation(myUniteCov), na.rm = T))
## RMS in this sample based on covered sites
percMethDF$RMS_coveredCpG = percMethDF$Nbr_methCpG / percMethDF$Nbr_coveredCpG
## merge with original metadata:
myMetaData = merge(myMetaData, percMethDF)
# calculate also RMS global, considering CpG covered or not (to compare)
myMetaData$RMS_allCpG_coveredOrNot = myMetaData$Nbr_methCpG / (myMetaData$M.Seqs_rawReads*10e6)
# calculate residuals of nbr of methCpG by nbr of covered CpG
myMetaData$res_Nbr_methCpG_Nbr_coveredCpG = residuals(
lm(myMetaData$Nbr_methCpG ~ myMetaData$Nbr_coveredCpG))
## REORDER myMetaData by sample ID
myMetaData = myMetaData[order(as.numeric(gsub("S", "", myMetaData$SampleID))),]
return(myMetaData)
}
fullMetadata <- mycalcRMS(uniteCovALL_woSexAndUnknowChr, fullMetadata)
fullMetadata_PAR <- mycalcRMS(uniteCov6_G1_woSexAndUnknowChrOVERLAP, fullMetadata_PAR)
fullMetadata_OFFS  <- mycalcRMS(uniteCov14_G2_woSexAndUnknowChrOVERLAP, fullMetadata_OFFS)
cor.test(fullMetadata_PAR$Nbr_coveredCpG,
fullMetadata_PAR$Nbr_methCpG, method = "spearman")
## S = 350, p-value = 2.15e-06, rho = 0.85
ggplot(fullMetadata_PAR, aes(x=Nbr_coveredCpG, y=Nbr_methCpG))+
geom_smooth(method = "lm", col="black")+
geom_point(aes(col=trtG1G2), size = 3)+ scale_color_manual(values = c("grey", "red")) +
theme_bw() + ggtitle(label = "Parents, CpG shared by half fish/trt")
## Check after RMS correction for coverage bias: CORRECTED (p-value = 0.4485)
cor.test(fullMetadata_PAR$Nbr_coveredCpG,
fullMetadata_PAR$RMS_coveredCpG, method = "spearman")
ggplot(fullMetadata_PAR, aes(x=Nbr_coveredCpG, y=RMS_coveredCpG))+
geom_smooth(method = "lm", col="black")+
geom_point(aes(col=trtG1G2), size = 3)+ scale_color_manual(values = c("grey", "red")) +
theme_bw() + ggtitle(label = "Parents, CpG shared by half fish/trt")
## and with residuals: COMPLETELY CORRECTED p-value = 0.9562
cor.test(fullMetadata_PAR$Nbr_coveredCpG,
fullMetadata_PAR$res_Nbr_methCpG_Nbr_coveredCpG, method = "spearman")
ggplot(fullMetadata_PAR, aes(x=Nbr_coveredCpG, y=res_Nbr_methCpG_Nbr_coveredCpG))+
geom_smooth(method = "lm", col="black")+
geom_point(aes(col=trtG1G2), size = 3)+ scale_color_manual(values = c("grey", "red")) +
theme_bw() + ggtitle(label = "Parents, CpG shared by half fish/trt")
############
## Offspring:
cor.test(fullMetadata_OFFS$Nbr_coveredCpG,
fullMetadata_OFFS$Nbr_methCpG, method = "spearman")
## S = 20254, p-value < 2.2e-16 rho = 0.91
ggplot(fullMetadata_OFFS, aes(x=Nbr_coveredCpG, y=Nbr_methCpG))+
geom_smooth(method = "lm", col="black")+
geom_point(aes(col=trtG1G2), size = 3)+ scale_color_manual(values = colOffs) +
scale_x_continuous("Number of cytosines covered") +
scale_y_continuous("Number of methylated cytosines") +
theme_bw() + ggtitle(label = "Offspring, CpG shared by half fish/trt")
## Plot distance to residuals:
fit <- lm(Nbr_methCpG ~ Nbr_coveredCpG, data = fullMetadata_OFFS)
plotdf <- fullMetadata_OFFS
plotdf$predicted <- predict(fit)   # Save the predicted values
plotdf$residuals <- residuals(fit)
ggplot(plotdf, aes(x=Nbr_coveredCpG, y=Nbr_methCpG))+
geom_smooth(method = "lm", col="black")+
geom_segment(aes(xend = Nbr_coveredCpG, yend = predicted), col = "grey") +
geom_point(aes(col=trtG1G2), size = 3)+ scale_color_manual(values = colOffs) +
scale_x_continuous("Number of cytosines covered") +
scale_y_continuous("Number of methylated cytosines") +
theme_bw() + ggtitle(label = "Offspring, CpG shared by half fish/trt")
## Check after RMS correction for coverage bias: SEMI CORRECTED (p-value = 0.01, rho = -0.24)
cor.test(fullMetadata_OFFS$Nbr_coveredCpG,
fullMetadata_OFFS$RMS_coveredCpG, method = "spearman")
ggplot(fullMetadata_OFFS, aes(x=Nbr_coveredCpG, y=RMS_coveredCpG))+
geom_point(aes(col=trtG1G2), size = 3)+ scale_color_manual(values = colOffs) +
geom_smooth(method = "lm", col="black")+
theme_bw() + ggtitle(label = "Offspring, CpG shared by half fish/trt")
## and with residuals: COMPLETELY CORRECTED p-value = 0.51
cor.test(fullMetadata_OFFS$Nbr_coveredCpG,
fullMetadata_OFFS$res_Nbr_methCpG_Nbr_coveredCpG, method = "spearman")
ggplot(fullMetadata_OFFS, aes(x=Nbr_coveredCpG, y=res_Nbr_methCpG_Nbr_coveredCpG))+
geom_point(aes(col=trtG1G2), size = 3)+ scale_color_manual(values = colOffs) +
geom_smooth(method = "lm", col="black")+
scale_x_continuous("Number of cytosines covered") +
scale_y_continuous("Residuals of number of methylated cytosines\n on number of cytosines covered") +
theme_bw() + ggtitle(label = "Offspring, CpG shared by half fish/trt")
mod = lm(MappingEfficiency.BSBoldvsGynogen ~ Sex, data = fullMetadata_OFFS)
summary(step(mod))
plot(ggpredict(mod, terms = c("Sex")), add.data = T)
mod = lm(M.Seqs_rawReads ~ Sex, data = fullMetadata_OFFS)
summary(step(mod))
plot(ggpredict(mod, terms = c("Sex")), add.data = T)
mod = lm(MeanCoverage ~ Sex, data = fullMetadata_OFFS)
summary(step(mod))
plot(ggpredict(mod, terms = c("Sex")), add.data = T)
mod = lm(Nbr_coveredCpG ~ Sex, data = fullMetadata_OFFS)
summary(step(mod))
plot(ggpredict(mod, terms = c("Sex")), add.data = T)
mod = lm(OverallPercentageMethylation ~ Sex, data = fullMetadata_OFFS)
summary(step(mod))
plot(ggpredict(mod, terms = c("Sex")), add.data = T)
mod = lm(res_Nbr_methCpG_Nbr_coveredCpG ~ Sex, data = fullMetadata_OFFS)
summary(step(mod)) # sex is significant p = 0.000157 ***
plot(ggpredict(mod, terms = c("Sex")), add.data = T)
fullMetadata_OFFS$res_Nbr_methCpG_Nbr_coveredCpG_div1000 <- (fullMetadata_OFFS$res_Nbr_methCpG_Nbr_coveredCpG)/1000
mod_Tol.Meth <- lmer(BCI ~ res_Nbr_methCpG_Nbr_coveredCpG_div1000*No.Worms*PAT + (1|brotherPairID)+ (1|Sex),
data=fullMetadata_OFFS, REML = F)
## Model selection:
step(mod_Tol.Meth, reduce.random = F) # Model found: BCI ~ No.Worms + PAT + (1 | brotherPairID) + (1 | Sex) + No.Worms:PAT
## The slope of BCI on nbrworms varies upon treatment but methylation does NOT vary with tolerance
mod_Tol.Meth <- lmer(BCI ~ No.Worms*PAT + (1|brotherPairID)+ (1|Sex),
data=fullMetadata_OFFS)
plot(ggpredict(mod_Tol.Meth, terms = c("No.Worms", "PAT")), add.data=T)+ theme_bw() +
ylab("Body Condition Index") + xlab("Number of worms") +
ggtitle("Predicted values of Body Condition Index in offspring")+
scale_color_manual(NULL, values = c("black", "red")) +
scale_fill_manual(NULL, values = c("black", "red"))  +
geom_point(size=0)+ # to have color key in legend as point
guides(colour = guide_legend(override.aes = list(size=3,linetype=0, fill = NA)))
## And by treatment instead of No.worms?
mod_Tol.Meth2 <- lmer(BCI ~ res_Nbr_methCpG_Nbr_coveredCpG_div1000*PAT*outcome + (1|brotherPairID)+ (1|Sex),
data=fullMetadata_OFFS, REML = F)
plot(ggpredict(mod_Tol.Meth2, terms = c("res_Nbr_methCpG_Nbr_coveredCpG_div1000","PAT", "outcome")), add.data=T)+
scale_color_manual(values = colOffs)
## Model selection:
step(mod_Tol.Meth2, reduce.random = F) # Model found: BCI ~ PAT + outcome + (1 | brotherPairID) + (1 | Sex) + PAT:outcome
## The slope of BCI on nbrworms varies upon parental treatment = methylation does NOT vary with tolerance
## By group, tolerance slope as a function of methylation residuals:
modFULL <- lmer(BCI ~ res_Nbr_methCpG_Nbr_coveredCpG_div1000*No.Worms + (1|brotherPairID) + (1|Sex),
data = fullMetadata_OFFS[fullMetadata_OFFS$trtG1G2 %in% c("NE_exposed", "E_exposed"),])
## Model selection:
step(modFULL, reduce.random = F) # Model found: BCI ~ (1 | brotherPairID) + (1 | Sex)
modFULL <- lmer(BCI ~ res_Nbr_methCpG_Nbr_coveredCpG_div1000*PAT + (1|brotherPairID) + (1|Sex),
data = fullMetadata_OFFS[fullMetadata_OFFS$trtG1G2 %in% c("NE_exposed", "E_exposed"),])
## Model selection:
step(modFULL, reduce.random = F) # Model found: BCI ~ PAT + (1 | brotherPairID) + (1 | Sex)
plot(ggpredict(modFULL, terms = c("res_Nbr_methCpG_Nbr_coveredCpG_div1000", "PAT")))
# Set up scatterplot
scatterplot <- ggplot(fullMetadata_OFFS,
aes(x = res_Nbr_methCpG_Nbr_coveredCpG,
y = BCI, fill=trtG1G2)) +
geom_point(pch=21, size =3, alpha = .8) +
guides(color = "none") +
scale_fill_manual(values = colOffs, name = "Treatment",
labels = c("G1 control - G2 control", "G1 control - G2 exposed", "G1 exposed - G2 control", "G1 exposed - G2 exposed")) +
theme(plot.margin = margin()) + theme_bw() +
theme(legend.position = "none") +
xlab("Methylation residuals (methylated sites/coverage")+
ylab("Body Condition Index")
# Define marginal histogram
marginal_distribution <- function(x, var, group) {
ggplot(x, aes_string(x = var, fill = group)) +
# geom_histogram(bins = 30, alpha = 0.4, position = "identity") +
geom_density(alpha = 0.6, size = 0.2) +
guides(fill = "none") +
scale_fill_manual(values = colOffs) +
theme_void() +
theme(plot.margin = margin())
}
# Set up marginal histograms
x_hist <- marginal_distribution(fullMetadata_OFFS, "res_Nbr_methCpG_Nbr_coveredCpG", "trtG1G2")
y_hist <- marginal_distribution(fullMetadata_OFFS, "BCI", "trtG1G2") +
coord_flip()
# Align histograms with scatterplot
aligned_x_hist <- align_plots(x_hist, scatterplot, align = "v")[[1]]
aligned_y_hist <- align_plots(y_hist, scatterplot, align = "h")[[1]]
# Arrange plots
cowplot::plot_grid(
aligned_x_hist, NULL, scatterplot, aligned_y_hist, ncol = 2, nrow = 2, rel_heights = c(0.2, 1), rel_widths = c(1, 0.2)
)
makePrettyMethCluster(uniteCovALL_woSexAndUnknowChr, fullMetadata,
my.cols.trt=c("#333333ff","#ff0000ff","#ffe680ff","#ff6600ff","#aaccffff","#aa00d4ff"),
my.cols.fam = c(1:4), nbrk = 8)
makePrettyMethCluster(uniteCovALL_G2_woSexAndUnknowChr, fullMetadata_OFFS,
my.cols.trt=c("#ffe680ff","#ff6600ff", "#aaccffff", "#aa00d4ff"),
my.cols.fam = c(1:4), nbrk = 8)
fullMetadata_OFFS$SampleID
# make distance matrix with B-C distances
data.dist = makeDatadistFUN(uniteCovALL_G2_woSexAndUnknowChr)
## Adonis test: importance of each predictor
adonis2(data.dist ~ PAT * outcome * Sex * brotherPairID, data = fullMetadata_OFFS)
perm <- how(nperm = 1000) # 1000 permutations
setBlocks(perm) <- with(fullMetadata_OFFS, brotherPairID) # define the permutation structure considering brotherPairID and sex
print(adonis2(data.dist ~ PAT * outcome, data = fullMetadata_OFFS, permutations = perm))
print(adonis2(data.dist ~ PAT * outcome * Sex, data = fullMetadata_OFFS, permutations = perm))
