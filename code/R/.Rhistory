message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
machine="mythinkpad" # define the machine we work on
loadALL = FALSE # only load CpG shared by half fish per trt group
loadannot = TRUE
sourceDMS = TRUE # Load the calculated DMS
source("R02.3_DATALOAD.R")
nrow(uniteCov14_G2_woSexAndUnknowChrOVERLAP) # methylBase object with 1001880 rows
## Add fam to bp
names(DMS_BP_G2_list) <- paste0(plyr::join(data.frame(BP = names(DMS_BP_G2_list)),
unique(data.frame(BP = fullMetadata_OFFS$brotherPairID, fam = fullMetadata_OFFS$Family)))[[2]],
"_", names(DMS_BP_G2_list))
## Extract DMS (by position)
myPosList = lapply(DMS_BP_G2_list, lapply, function(x){paste(x$chr, x$end)})
## Find DMS present in at least 4 BP out of 8 (half):
## 1. TREATMENT fish (DMS different parents)
x <- lapply(myPosList, function(x){unlist(x[["DMS_15pc_BP_treatment"]])})
f <- table(unlist((x))) # each DMS present between 1 and 8 times
tokeep <- names(f)[f >= 4]
length(tokeep) # 1257 DMS
## Keep the DMS present in 4 families minimum
DMS_BP_G2_list_INTER4 <- lapply(x, function(x){x[x %in% tokeep]})
## Reorder by family:
DMS_BP_G2_list_INTER4 <- DMS_BP_G2_list_INTER4[
names(DMS_BP_G2_list_INTER4)[order(names(DMS_BP_G2_list_INTER4))]]
## UpSet plot
# The majority of differences are within BP or family
UpSetR::upset(fromList(DMS_BP_G2_list_INTER4), order.by = "freq", nsets = 8, keep.order = T,
sets = names(DMS_BP_G2_list_INTER4), shade.color = "grey")
######################
## Features Annotation (use package genomation v1.24.0)
## Parents comparison:
diffAnn_PAR = annotateWithGeneParts(as(DMS15pc_G1_half,"GRanges"),annotBed12)
######################
## Features Annotation (use package genomation v1.24.0)
## Parents comparison:
diffAnn_PAR = annotateWithGeneParts(as(DMS15pc_G1_half,"GRanges"),annotBed12)
diffAnn_PAR
diffAnn_PAR
## Features Annotation (use package genomation v1.24.0)
## Parents comparison:
diffAnn_PAR = annotateWithGeneParts(as(DMS15pc_G1_half,"GRanges"),annotBed12)
## Features Annotation (use package genomation v1.24.0)
## Parents comparison:
diffAnn_PAR = annotateWithGeneParts(as(DMS15pc_G1_half,"GRanges"),annotBed12)
diffAnn_PAR
## Offspring from control parents comparison:
diffAnn_G2_controlG1 = annotateWithGeneParts(as(DMS15pc_G2_controlG1_half,"GRanges"),annotBed12)
## Offspring from control parents comparison:
diffAnn_G2_controlG1 = annotateWithGeneParts(as(DMS15pc_G2_controlG1_half,"GRanges"),annotBed12)
diffAnn_G2_controlG1
## Offspring from infected parents comparison:
diffAnn_G2_infectedG1 = annotateWithGeneParts(as(DMS15pc_G2_infectedG1_half,"GRanges"),annotBed12)
diffAnn_G2_infectedG1
## Function to get DMS info
myDMSinfo <- function(DMSobject, fromUniteCov){
DMS = paste(DMSobject$chr, DMSobject$start, DMSobject$end)
meth.diff = DMSobject$meth.diff
direction = ifelse(DMSobject$meth.diff > 0, "hyper", "hypo")
percentDMS = length(DMS)/nrow(fromUniteCov)*100
return(list(DMS = DMS, meth.diff = meth.diff, direction = direction, percentDMS = percentDMS))
}
## Run the function to get DMS info
DMS_info_G1 <- myDMSinfo(DMS15pc_G1_half, uniteCov6_G1_woSexAndUnknowChrOVERLAP)
DMS_info_G2_G1c_final <- myDMSinfo(DMS15pc_G2_controlG1_half, uniteCov14_G2_woSexAndUnknowChrOVERLAP)
DMS_info_G2_G1i_final <- myDMSinfo(DMS15pc_G2_infectedG1_half,uniteCov14_G2_woSexAndUnknowChrOVERLAP)
DMS_info_G2_G1i_final
round(DMS_info_G1$percentDMS, 2)
##################
## Venn diagram ##
##################
myVennFUN <- function(A, B, C, catnames, myCols = c("grey","green","red")){
futile.logger::flog.threshold(futile.logger::ERROR, name = "VennDiagramLogger")#to rm log files
Venn <- venn.diagram(
x = list(A, B, C), category.names = catnames, filename = NULL,
margin = 0, lwd = 2, lty = 'blank', fill = myCols,
cex = .4, fontface = "bold",fontfamily = "sans", print.mode=c("raw","percent"),
cat.cex = 0.4, cat.fontface = "bold", cat.default.pos = "outer",
cat.col = myCols, cat.pos = c(-27, 27, 135), cat.dist = c(0.055, 0.055, 0.055),
cat.fontfamily = "sans", rotation = 1
)
return(Venn)
}
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
machine="mythinkpad" # define the machine we work on
loadALL = FALSE # only load CpG shared by half fish per trt group
loadannot = TRUE # load genome annotations
sourceDMS = TRUE # Load the calculated DMS
source("R02.3_DATALOAD.R")
sapply(1:5,sqrt)
class(sapply(1:5,sqrt))
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
# NB: rm html when change previous scripts
# cache.extra = tools::md5sum('my-precious.csv'). The former means if the modification time of the file has been changed, we need to invalidate the cache. The latter means if the content of the file has been modified, we update the cache.
machine="mythinkpad" # define the machine we work on
loadALL = FALSE # only load CpG shared by half fish per trt group
loadannot = TRUE # load genome annotations
sourceDMS = TRUE # Load the calculated DMS
source("R02.3_DATALOAD.R")
## Features Annotation (use package genomation v1.24.0)
## NB Promoters are defined by options at genomation::readTranscriptFeatures function.
## The default option is to take -1000,+1000bp around the TSS and you can change that.
## -> following Heckwolf 2020 and Sagonas 2020, we consider 1500bp upstream and 500 bp downstream
## Parents comparison:
diffAnn_PAR = annotateWithGeneParts(as(DMS15pc_G1_half,"GRanges"),annotBed12)
## Offspring from control parents comparison:
diffAnn_G2_controlG1 = annotateWithGeneParts(as(DMS15pc_G2_controlG1_half,"GRanges"),annotBed12)
## Offspring from infected parents comparison:
diffAnn_G2_infectedG1 = annotateWithGeneParts(as(DMS15pc_G2_infectedG1_half,"GRanges"),annotBed12)
par(mfrow=c(1,3))
par(mar = c(.1,0.1,5,0.1)) # Set the margin on all sides to 2
## Parents comparison:
diffAnn_PAR = annotateWithGeneParts(as(DMS15pc_G1_half,"GRanges"),annotBed12)
diffAnn_PAR
plotTargetAnnotation(diffAnn_PAR,precedence=TRUE, main="DMS G1", cex.legend = 1, border="white")
plotTargetAnnotation
?plotTargetAnnotation()
methylKit::plotTargetAnnotation(diffAnn_PAR,precedence=TRUE, main="DMS G1", cex.legend = 1, border="white")
genomation::plotTargetAnnotation(diffAnn_PAR,precedence=TRUE, main="DMS G1", cex.legend = 1, border="white")
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
## Data getting loaded:
#uniteCovALL_woSexAndUnknowChr #-> 55530 CpG positions shared by all fish
#uniteCov6_G1_woSexAndUnknowChrOVERLAP #-> 1001880 CpG positions shared by half the parents in each trt group, overlapping with the parental ones
#uniteCov14_G2_woSexAndUnknowChrOVERLAP#-> 1001880 CpG positions shared by half the offspring in each trt group, overlapping with the offspring ones
## Kaufmann et al. 2014: Body condition of the G2 fish, an estimate of fish health and a predictor
# of energy reserves and reproductive success, was calculated using there residuals from the
# regression of body mass on body length (Chellappaet al.1995).
fullMetadata_OFFS$BCI <- residuals(lmer(Wnettofin ~ Slfin * Sex + (1|brotherPairID), data=fullMetadata_OFFS))
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
machine="mythinkpad" # define the machine we work on
loadALL = FALSE # only load CpG shared by half fish per trt group
loadannot = FALSE
sourceDMS = FALSE
source("R02.3_DATALOAD.R")
## Data getting loaded:
#uniteCovALL_woSexAndUnknowChr #-> 55530 CpG positions shared by all fish
#uniteCov6_G1_woSexAndUnknowChrOVERLAP #-> 1001880 CpG positions shared by half the parents in each trt group, overlapping with the parental ones
#uniteCov14_G2_woSexAndUnknowChrOVERLAP#-> 1001880 CpG positions shared by half the offspring in each trt group, overlapping with the offspring ones
## Kaufmann et al. 2014: Body condition of the G2 fish, an estimate of fish health and a predictor
# of energy reserves and reproductive success, was calculated using there residuals from the
# regression of body mass on body length (Chellappaet al.1995).
fullMetadata_OFFS$BCI <- residuals(lmer(Wnettofin ~ Slfin * Sex + (1|brotherPairID), data=fullMetadata_OFFS))
## and for parents (no sex difference, only males):
fullMetadata_PAR$BCI <- residuals(lmer(Wnettofin ~ Slfin + (1|brotherPairID), data=fullMetadata_PAR))
## Effect of paternal treatment on body condition of offspring:
## Kaufmann et al. 2014:
# To investigate in which way paternal G1 exposure affected offspring tolerance,
# we tested how the relationship between G2 body condition and infection intensity
# was affected by paternal G1 exposure. This was tested in a linear mixed model on
# G2 body condition with paternal G1 treatment and the interaction between
# paternal G1 treatment and G2 infection intensity as fixed effects. Maternal
# half-sibship identity was set as a random effect
## Effect of treatment groups of offspring on body condition:
## Kaufmann et al. 2014:
# The linear mixed effect model (nlme function in R) included G2 body condition as dependent variable,
# sex, G2 treatment (exposed vs. control), paternal G1 treatment (exposed vs. control)
# and their interactions as fixed effects as well as maternal G2 half-sibship identity as a random effect
mod1 <- lme(BCI ~ offsTrt * patTrt, random=~1|brotherPairID,data=fullMetadata_OFFS)
anova(mod1) # strong significant effect of both offspring trt & paternal + interactions
mod1.2 <- lme(BCI ~  trtG1G2, random=~1|brotherPairID,data=fullMetadata_OFFS)
## pairwise posthoc test
emmeans(mod1.2, list(pairwise ~ trtG1G2), adjust = "tukey")
## Control father - treatment offspring has a strongly significantly lower BC than
## every other group, same as Kaufmann et al. 2014
myplot1 <- ggplot(fullMetadata_OFFS, aes(x=trtG1G2, y = BCI, fill=trtG1G2))+
geom_boxplot()+
geom_signif(comparisons = list(c("NE_control", "NE_exposed")),
map_signif_level=TRUE, annotations="***",
y_position = 150, tip_length = 0, vjust=0.4) +
geom_signif(comparisons = list(c("NE_exposed", "E_control")),
map_signif_level=TRUE, annotations="***",
y_position = 200, tip_length = 0, vjust=0.4) +
geom_signif(comparisons = list(c("NE_exposed", "E_exposed")),
map_signif_level=TRUE, annotations="***",
y_position = 250, tip_length = 0, vjust=0.4) +
scale_fill_manual(values = colOffs)+
theme_bw() + theme(legend.position = "none") +
ylab("Body Condition Index")
myplot1
modTol1 <- lmer(BCI ~ PAT*outcome*No.Worms + (1|brotherPairID) + (1|Sex), data=fullMetadata_OFFS)
step(modTol1, reduce.random = F) # Model found: keep ALL
modTol1_noworms <- lmer(BCI ~ PAT*outcome + (1|brotherPairID) + (1|Sex), data=fullMetadata_OFFS)
modTol1_noPAT <- lmer(BCI ~ outcome*No.Worms + (1|brotherPairID) + (1|Sex), data=fullMetadata_OFFS)
modTol1_nooffsp <- lmer(BCI ~ PAT*No.Worms + (1|brotherPairID) + (1|Sex), data=fullMetadata_OFFS)
lrtest(modTol1, modTol1_noworms) # chi2 11.375  p= 0.003387 **
lrtest(modTol1, modTol1_noPAT) # chi2 41.717  p=4.608e-09 ***
lrtest(modTol1, modTol1_nooffsp) # chi2 24.308  p=5.268e-06 ***
## Let's look at tolerance by paternal treatment:
modTol <- lmer(BCI ~ PAT*No.Worms + (1|brotherPairID) + (1|Sex), data=fullMetadata_OFFS)
step(modTol, reduce.random = F) # Model found: keep ALL
modTol_noworms <- lmer(BCI ~ PAT + (1|brotherPairID) + (1|Sex), data=fullMetadata_OFFS)
modTol_noPAT <- lmer(BCI ~ No.Worms + (1|brotherPairID) + (1|Sex), data=fullMetadata_OFFS)
lrtest(modTol, modTol1_noworms) # chi2 12.932  p< 2.2e-16 ***
lrtest(modTol, modTol1_noPAT) # chi2 17.409  p=3.014e-05 ***
## Slope of tolerance is significantly different between both paternal treatment, with fish from control parents being less tolerant to parasitism
pred <- ggpredict(modTol, terms = c("No.Worms", "PAT"), )
myplot2 <- plot(pred, add.data = TRUE) + scale_color_manual(values = colOffs[c(2,4)]) + theme_bw() +
ylab("Body Condition Index") + scale_x_continuous("Number of worms", breaks = 0:10) +
labs(col=NULL) + ggtitle("Predicted values of Body Condition Index in offspring")
myplot2
mycalcRMS <- function(myUniteCov, myMetaData){
percMethMat = methylKit::percMethylation(myUniteCov)
# create a dataframe with all info
percMethDF = data.frame(SampleID = colnames(percMethMat),
## number of methylated sites
Nbr_methCpG = colSums(percMethMat>=70 & !is.na(percMethMat)),#512493
## number of sites covered in this sample
Nbr_coveredCpG = colSums(!is.na(percMethMat)), #1015735
## number of sites NOT covered in this sample
Nbr_NOTcoveredCpG = colSums(is.na(percMethMat)))
## RMS in this sample based on covered sites
percMethDF$RMS_coveredCpG = percMethDF$Nbr_methCpG / percMethDF$Nbr_coveredCpG #0.5045538
## merge with original metadata:
myMetaData = merge(myMetaData, percMethDF)
# calculate also RMS global, considering CpG covered or not (to compare)
myMetaData$RMS_allCpG_coveredOrNot = myMetaData$Nbr_methCpG / (myMetaData$M.Seqs_rawReads*10e6)
# calculate residuals of nbr of methCpG by nbr of covered CpG
myMetaData$res_Nbr_methCpG_Nbr_coveredCpG = residuals(
lm(myMetaData$Nbr_methCpG ~ myMetaData$Nbr_coveredCpG))
return(myMetaData)
}
fullMetadata_ALL <- mycalcRMS(uniteCovALL_woSexAndUnknowChr, fullMetadata)
fullMetadata_PAR_half <- mycalcRMS(uniteCov6_G1_woSexAndUnknowChrOVERLAP, fullMetadata_PAR)
fullMetadata_OFFS_half  <- mycalcRMS(uniteCov14_G2_woSexAndUnknowChrOVERLAP, fullMetadata_OFFS)
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
## Nbr samples: 135
nrow(fullMetadata)
# Mean nbr of million reads: 11.3
mean(fullMetadata$M.Seqs_rawReads)
# 95% confidence interval: 0.33
qnorm(0.975)*sd(fullMetadata$M.Seqs_rawReads)/sqrt(nrow(fullMetadata))
# Average mapping efficiency +/-SD = 85.4% +/-0.48
mean(fullMetadata$MappingEfficiency.BSBoldvsGynogen)
qnorm(0.975)*sd(fullMetadata$MappingEfficiency.BSBoldvsGynogen)/sqrt(nrow(fullMetadata))
## Does Sex affect the number of methylated sites? YES
## + family as random factor
modFull <- lmer(Nbr_methCpG ~ trtG1G2 * Sex + (1|brotherPairID),
data = fullMetadata_OFFS_half, REML = F) # REML =F for model comparison
mod_noSex <- lmer(Nbr_methCpG ~ trtG1G2 + (1|brotherPairID),
data = fullMetadata_OFFS_half, REML = F)
mod_noTrt <- lmer(Nbr_methCpG ~ Sex + (1|brotherPairID),
data = fullMetadata_OFFS_half, REML = F)
mod_noInteractions <- lmer(Nbr_methCpG ~ trtG1G2 + Sex + (1|brotherPairID),
data = fullMetadata_OFFS_half, REML = F)
lrtest(modFull, mod_noSex) # sex is VERY VERY significant p = 0.001776 **
lrtest(modFull, mod_noTrt) # trt is signif p = 0.0208 *
lrtest(modFull, mod_noInteractions) # interactions are significant 0.0151 *
## Plot
ggplot(fullMetadata_OFFS_half, aes(trtG1G2, Nbr_methCpG, group=interaction(trtG1G2, Sex))) +
facet_grid(~Sex) +
geom_violin() +
geom_boxplot(aes(fill = trtG1G2), width = 0.2) +
geom_jitter(width = .1, size = 1, pch = 21, fill = "white") +
scale_fill_manual(values = colOffs) +
theme_bw()  + theme(legend.position = "none")
## Does Sex affect the residuals of nbr of methylated sites by nbr of sites? YES
## + family as random factor
modFull <- lmer(res_Nbr_methCpG_Nbr_coveredCpG ~ trtG1G2 * Sex + (1|brotherPairID),
data = fullMetadata_OFFS_half, REML = F) # REML =F for model comparison
mod_noSex <- lmer(res_Nbr_methCpG_Nbr_coveredCpG ~ trtG1G2 + (1|brotherPairID),
data = fullMetadata_OFFS_half, REML = F)
mod_noTrt <- lmer(res_Nbr_methCpG_Nbr_coveredCpG ~ Sex + (1|brotherPairID),
data = fullMetadata_OFFS_half, REML = F)
mod_noInteractions <- lmer(res_Nbr_methCpG_Nbr_coveredCpG ~ trtG1G2 + Sex + (1|brotherPairID),
data = fullMetadata_OFFS_half, REML = F)
lrtest(modFull, mod_noSex) # sex is significant p = 0.0002124 ***
lrtest(modFull, mod_noTrt) # trt is not significant any longer
lrtest(modFull, mod_noInteractions) # interactions are not significant any longer
## Plot
ggplot(fullMetadata_OFFS_half, aes(trtG1G2, res_Nbr_methCpG_Nbr_coveredCpG,
group=interaction(trtG1G2, Sex))) +
facet_grid(~Sex) +
geom_violin() +
geom_boxplot(aes(fill = trtG1G2), width = 0.2) +
geom_jitter(width = .1, size = 1, pch = 21, fill = "white") +
scale_fill_manual(values = colOffs) +
theme_bw() + theme(legend.position = "none")
cor.test(fullMetadata_PAR_half$Nbr_coveredCpG,
fullMetadata_PAR_half$Nbr_methCpG, method = "spearman")
## S = 350, p-value = 2.15e-06, rho = 0.85
ggplot(fullMetadata_PAR_half, aes(x=Nbr_coveredCpG, y=Nbr_methCpG))+
geom_smooth(method = "lm", col="black")+
geom_point(aes(col=trtG1G2), size = 3)+ scale_color_manual(values = c("grey", "red")) +
theme_bw() + ggtitle(label = "Parents, CpG shared by half fish/trt")
## Check after RMS correction for coverage bias: CORRECTED (p-value = 0.4485)
cor.test(fullMetadata_PAR_half$Nbr_coveredCpG,
fullMetadata_PAR_half$RMS_coveredCpG, method = "spearman")
ggplot(fullMetadata_PAR_half, aes(x=Nbr_coveredCpG, y=RMS_coveredCpG))+
geom_smooth(method = "lm", col="black")+
geom_point(aes(col=trtG1G2), size = 3)+ scale_color_manual(values = c("grey", "red")) +
theme_bw() + ggtitle(label = "Parents, CpG shared by half fish/trt")
## and with residuals: COMPLETELY CORRECTED p-value = 0.9562
cor.test(fullMetadata_PAR_half$Nbr_coveredCpG,
fullMetadata_PAR_half$res_Nbr_methCpG_Nbr_coveredCpG, method = "spearman")
ggplot(fullMetadata_PAR_half, aes(x=Nbr_coveredCpG, y=res_Nbr_methCpG_Nbr_coveredCpG))+
geom_smooth(method = "lm", col="black")+
geom_point(aes(col=trtG1G2), size = 3)+ scale_color_manual(values = c("grey", "red")) +
theme_bw() + ggtitle(label = "Parents, CpG shared by half fish/trt")
############
## Offspring:
cor.test(fullMetadata_OFFS_half$Nbr_coveredCpG,
fullMetadata_OFFS_half$Nbr_methCpG, method = "spearman")
## S = 20254, p-value < 2.2e-16 rho = 0.91
ggplot(fullMetadata_OFFS_half, aes(x=Nbr_coveredCpG, y=Nbr_methCpG))+
geom_smooth(method = "lm", col="black")+
geom_point(aes(col=trtG1G2), size = 3)+ scale_color_manual(values = colOffs) +
scale_x_continuous("Number of cytosines covered") +
scale_y_continuous("Number of methylated cytosines") +
theme_bw() + ggtitle(label = "Offspring, CpG shared by half fish/trt")
## Plot distance to residuals:
fit <- lm(Nbr_methCpG ~ Nbr_coveredCpG, data = fullMetadata_OFFS_half)
plotdf <- fullMetadata_OFFS_half
plotdf$predicted <- predict(fit)   # Save the predicted values
plotdf$residuals <- residuals(fit)
ggplot(plotdf, aes(x=Nbr_coveredCpG, y=Nbr_methCpG))+
geom_smooth(method = "lm", col="black")+
geom_segment(aes(xend = Nbr_coveredCpG, yend = predicted), col = "grey") +
geom_point(aes(col=trtG1G2), size = 3)+ scale_color_manual(values = colOffs) +
scale_x_continuous("Number of cytosines covered") +
scale_y_continuous("Number of methylated cytosines") +
theme_bw() + ggtitle(label = "Offspring, CpG shared by half fish/trt")
## Check after RMS correction for coverage bias: SEMI CORRECTED (p-value = 0.01, rho = -0.24)
cor.test(fullMetadata_OFFS_half$Nbr_coveredCpG,
fullMetadata_OFFS_half$RMS_coveredCpG, method = "spearman")
ggplot(fullMetadata_OFFS_half, aes(x=Nbr_coveredCpG, y=RMS_coveredCpG))+
geom_point(aes(col=trtG1G2), size = 3)+ scale_color_manual(values = colOffs) +
geom_smooth(method = "lm", col="black")+
theme_bw() + ggtitle(label = "Offspring, CpG shared by half fish/trt")
## and with residuals: COMPLETELY CORRECTED p-value = 0.51
cor.test(fullMetadata_OFFS_half$Nbr_coveredCpG,
fullMetadata_OFFS_half$res_Nbr_methCpG_Nbr_coveredCpG, method = "spearman")
ggplot(fullMetadata_OFFS_half, aes(x=Nbr_coveredCpG, y=res_Nbr_methCpG_Nbr_coveredCpG))+
geom_point(aes(col=trtG1G2), size = 3)+ scale_color_manual(values = colOffs) +
geom_smooth(method = "lm", col="black")+
scale_x_continuous("Number of cytosines covered") +
scale_y_continuous("Residuals of number of methylated cytosines\n on number of cytosines covered") +
theme_bw() + ggtitle(label = "Offspring, CpG shared by half fish/trt")
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
fullMetadata_OFFS_half$res_Nbr_methCpG_Nbr_coveredCpG_div1000 <- (fullMetadata_OFFS_half$res_Nbr_methCpG_Nbr_coveredCpG)/1000
mod_Tol.Meth <- lmer(BCI ~ res_Nbr_methCpG_Nbr_coveredCpG_div1000*No.Worms + (1|brotherPairID)+ (1|Sex),
data=fullMetadata_OFFS_half, REML = F)
## Model selection:
step(mod_Tol.Meth, reduce.random = F) # Model found: BCI ~ No.Worms + (1 | brotherPairID) + (1 | Sex)
## The slope of BCI on nbrworms varies upon parental treatment = methylation does NOT vary with tolerance
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
fullMetadata_OFFS
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
mod_Tol.Meth
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
predict(mod_Tol.Meth)
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
ggpredict(mod_Tol.Meth)
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
plot(ggpredict(mod_Tol.Meth))
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
plot(ggpredict(mod_Tol.Meth, terms = c("res_Nbr_methCpG_Nbr_coveredCpG_div1000", "No.Worms")))
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
## And by treatment instead of No.worms?
mod_Tol.Meth2 <- lmer(BCI ~ res_Nbr_methCpG_Nbr_coveredCpG_div1000*trtG1G2 + (1|brotherPairID)+ (1|Sex),
data=fullMetadata_OFFS_half, REML = F)
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
## Model selection:
step(mod_Tol.Meth2, reduce.random = F) # Model found: BCI ~ No.Worms + (1 | brotherPairID) + (1 | Sex)
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
plot(ggpredict(mod_Tol.Meth2, terms = c("res_Nbr_methCpG_Nbr_coveredCpG_div1000", "trtG1G2")))
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
plot(ggpredict(mod_Tol.Meth2, terms = c("res_Nbr_methCpG_Nbr_coveredCpG_div1000", "trtG1G2")), add.data=T)
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
plot(ggpredict(mod_Tol.Meth2, terms = c("res_Nbr_methCpG_Nbr_coveredCpG_div1000", "trtG1G2")), add.data=T)+
scale_color_manual(values = colOffs)
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
## And by treatment instead of No.worms?
mod_Tol.Meth2 <- lmer(BCI ~ res_Nbr_methCpG_Nbr_coveredCpG_div1000*PAT*outcome + (1|brotherPairID)+ (1|Sex),
data=fullMetadata_OFFS_half, REML = F)
## Model selection:
step(mod_Tol.Meth2, reduce.random = F) # Model found: BCI ~ trtG1G2 + (1 | brotherPairID) + (1 | Sex)
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
## The slope of BCI on nbrworms varies upon parental treatment = methylation does NOT vary with tolerance
mod_Tol.Meth2 <- lmer(BCI ~ PAT + outcome + PAT:outcome + (1|brotherPairID)+ (1|Sex),
data=fullMetadata_OFFS_half, REML = F)
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
plot(ggpredict(mod_Tol.Meth2, terms = c("res_Nbr_methCpG_Nbr_coveredCpG_div1000", "PAT", "outcome")), add.data=T)+
scale_color_manual(values = colOffs)
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
plot(ggpredict(mod_Tol.Meth2, terms = c("PAT", "outcome")), add.data=T)+
scale_color_manual(values = colOffs)
mod_BCI.Meth <- lmer(BCI ~ res_Nbr_methCpG_Nbr_coveredCpG_div1000 + (1|brotherPairID)+ (1|Sex),
data=fullMetadata_OFFS_half, REML = F)
## Model selection:
mod_BCI.Meth_nometh <- lmer(BCI ~ 1 + (1|brotherPairID)+ (1|Sex),
data=fullMetadata_OFFS_half, REML = F)
lrtest(mod_BCI.Meth, mod_BCI.Meth_nometh)## Methylation does NOT vary with BCI
step(mod_BCI.Meth, reduce.random = F) # Model found: BCI ~ (1 | brotherPairID) + (1 | Sex)
plot(ggpredict(mod_BCI.Meth), add.data=T)
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
## By group, tolerance slope as a function of methylation residuals:
modFULL <- lmer(BCI ~ No.Worms : trtG1G2 + (1|brotherPairID) + (1|Sex),
data = fullMetadata_OFFS_half[fullMetadata_OFFS_half$trtG1G2 %in% c("NE_exposed", "E_exposed"),])
coef(modFULL)[1]
# infected father: BCI = 7.1 NoWorms + various intercepts by family and sex
# control father: BCI = -15.6 NoWorms + various intercepts by family and sex
predict <- ggpredict(modFULL, terms = c("No.Worms", "trtG1G2"))
slope_NE_exposed <- predict[predict$group %in% "NE_exposed",][2,2] - predict[predict$group %in% "NE_exposed",][1,2]
slope_E_exposed <- predict[predict$group %in% "E_exposed",][2,2] - predict[predict$group %in% "E_exposed",][1,2]
slope_NE_exposed
meanMeth_NE_exposed <- mean(fullMetadata_OFFS_half[fullMetadata_OFFS_half$trtG1G2 %in% c("NE_exposed"),"res_Nbr_methCpG_Nbr_coveredCpG"])
meanMeth_E_exposed <- mean(fullMetadata_OFFS_half[fullMetadata_OFFS_half$trtG1G2 %in% c("E_exposed"),"res_Nbr_methCpG_Nbr_coveredCpG"])
df <- data.frame(group = c("NE_exposed", "E_exposed"),
slope = c(slope_NE_exposed, slope_E_exposed),
meanMeth = c(meanMeth_NE_exposed, meanMeth_E_exposed))
ggplot(df, aes(x = slope, y = meanMeth, col =group))+
geom_point() + theme_bw()
## Indication: Low tolerance = high methylation / high tolerance = low methylation
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
## By group, tolerance slope as a function of methylation residuals:
modFULL <- lmer(BCI ~ res_Nbr_methCpG_Nbr_coveredCpG_div1000*No.Worms + (1|brotherPairID) + (1|Sex),
data = fullMetadata_OFFS_half[fullMetadata_OFFS_half$trtG1G2 %in% c("NE_exposed", "E_exposed"),])
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
## Model selection:
step(modFULL, reduce.random = F) # Model found: BCI ~ No.Worms + (1 | brotherPairID) + (1 | Sex)
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
modFULL <- lmer(BCI ~ res_Nbr_methCpG_Nbr_coveredCpG_div1000*PAT + (1|brotherPairID) + (1|Sex),
data = fullMetadata_OFFS_half[fullMetadata_OFFS_half$trtG1G2 %in% c("NE_exposed", "E_exposed"),])
## Model selection:
step(modFULL, reduce.random = F) # Model found: BCI ~ (1 | brotherPairID) + (1 | Sex)
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
ggpredict(modFULL, terms = c("res_Nbr_methCpG_Nbr_coveredCpG_div1000", "PAT")
library(knitr)
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
plot(ggpredict(modFULL, terms = c("res_Nbr_methCpG_Nbr_coveredCpG_div1000", "PAT")))
list(A=1, B=2)
