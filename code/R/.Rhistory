## Does Sex affect the residuals of nbr of methylated sites by nbr of sites? YES
## + family as random factor
modFull <- lmer(res_Nbr_methCpG_Nbr_coveredCpG ~ trtG1G2 * Sex + (1|brotherPairID),
data = fullMetadata_OFFS_half, REML = F) # REML =F for model comparison
mod_noSex <- lmer(res_Nbr_methCpG_Nbr_coveredCpG ~ trtG1G2 + (1|brotherPairID),
data = fullMetadata_OFFS_half, REML = F)
mod_noTrt <- lmer(res_Nbr_methCpG_Nbr_coveredCpG ~ Sex + (1|brotherPairID),
data = fullMetadata_OFFS_half, REML = F)
mod_noInteractions <- lmer(res_Nbr_methCpG_Nbr_coveredCpG ~ trtG1G2 + Sex + (1|brotherPairID),
data = fullMetadata_OFFS_half, REML = F)
lrtest(modFull, mod_noSex) # sex is significant p = 0.0002124 ***
lrtest(modFull, mod_noTrt) # trt is not significant any longer
lrtest(modFull, mod_noInteractions) # interactions are not significant any longer
## Plot
ggplot(fullMetadata_OFFS_half, aes(trtG1G2, res_Nbr_methCpG_Nbr_coveredCpG,
group=interaction(trtG1G2, Sex))) +
facet_grid(~Sex) +
geom_violin() +
geom_boxplot(aes(fill = trtG1G2), width = 0.2) +
geom_jitter(width = .1, size = 1, pch = 21, fill = "white") +
scale_fill_manual(values = colOffs) +
theme_bw() + theme(legend.position = "none")
cor.test(fullMetadata_PAR_half$Nbr_coveredCpG,
fullMetadata_PAR_half$Nbr_methCpG, method = "spearman")
## S = 350, p-value = 2.15e-06, rho = 0.85
ggplot(fullMetadata_PAR_half, aes(x=Nbr_coveredCpG, y=Nbr_methCpG))+
geom_smooth(method = "lm", col="black")+
geom_point(aes(col=trtG1G2), size = 3)+ scale_color_manual(values = c("grey", "red")) +
theme_bw() + ggtitle(label = "Parents, CpG shared by half fish/trt")
## Check after RMS correction for coverage bias: CORRECTED (p-value = 0.4485)
cor.test(fullMetadata_PAR_half$Nbr_coveredCpG,
fullMetadata_PAR_half$RMS_coveredCpG, method = "spearman")
ggplot(fullMetadata_PAR_half, aes(x=Nbr_coveredCpG, y=RMS_coveredCpG))+
geom_smooth(method = "lm", col="black")+
geom_point(aes(col=trtG1G2), size = 3)+ scale_color_manual(values = c("grey", "red")) +
theme_bw() + ggtitle(label = "Parents, CpG shared by half fish/trt")
## and with residuals: COMPLETELY CORRECTED p-value = 0.9562
cor.test(fullMetadata_PAR_half$Nbr_coveredCpG,
fullMetadata_PAR_half$res_Nbr_methCpG_Nbr_coveredCpG, method = "spearman")
ggplot(fullMetadata_PAR_half, aes(x=Nbr_coveredCpG, y=res_Nbr_methCpG_Nbr_coveredCpG))+
geom_smooth(method = "lm", col="black")+
geom_point(aes(col=trtG1G2), size = 3)+ scale_color_manual(values = c("grey", "red")) +
theme_bw() + ggtitle(label = "Parents, CpG shared by half fish/trt")
############
## Offspring:
cor.test(fullMetadata_OFFS_half$Nbr_coveredCpG,
fullMetadata_OFFS_half$Nbr_methCpG, method = "spearman")
## S = 20254, p-value < 2.2e-16 rho = 0.91
ggplot(fullMetadata_OFFS_half, aes(x=Nbr_coveredCpG, y=Nbr_methCpG))+
geom_smooth(method = "lm", col="black")+
geom_point(aes(col=trtG1G2), size = 3)+ scale_color_manual(values = colOffs) +
scale_x_continuous("Number of cytosines covered") +
scale_y_continuous("Number of methylated cytosines") +
theme_bw() + ggtitle(label = "Offspring, CpG shared by half fish/trt")
## Plot distance to residuals:
fit <- lm(Nbr_methCpG ~ Nbr_coveredCpG, data = fullMetadata_OFFS_half)
plotdf <- fullMetadata_OFFS_half
plotdf$predicted <- predict(fit)   # Save the predicted values
plotdf$residuals <- residuals(fit)
ggplot(plotdf, aes(x=Nbr_coveredCpG, y=Nbr_methCpG))+
geom_smooth(method = "lm", col="black")+
geom_segment(aes(xend = Nbr_coveredCpG, yend = predicted), col = "grey") +
geom_point(aes(col=trtG1G2), size = 3)+ scale_color_manual(values = colOffs) +
scale_x_continuous("Number of cytosines covered") +
scale_y_continuous("Number of methylated cytosines") +
theme_bw() + ggtitle(label = "Offspring, CpG shared by half fish/trt")
## Check after RMS correction for coverage bias: SEMI CORRECTED (p-value = 0.01, rho = -0.24)
cor.test(fullMetadata_OFFS_half$Nbr_coveredCpG,
fullMetadata_OFFS_half$RMS_coveredCpG, method = "spearman")
ggplot(fullMetadata_OFFS_half, aes(x=Nbr_coveredCpG, y=RMS_coveredCpG))+
geom_point(aes(col=trtG1G2), size = 3)+ scale_color_manual(values = colOffs) +
geom_smooth(method = "lm", col="black")+
theme_bw() + ggtitle(label = "Offspring, CpG shared by half fish/trt")
## and with residuals: COMPLETELY CORRECTED p-value = 0.51
cor.test(fullMetadata_OFFS_half$Nbr_coveredCpG,
fullMetadata_OFFS_half$res_Nbr_methCpG_Nbr_coveredCpG, method = "spearman")
ggplot(fullMetadata_OFFS_half, aes(x=Nbr_coveredCpG, y=res_Nbr_methCpG_Nbr_coveredCpG))+
geom_point(aes(col=trtG1G2), size = 3)+ scale_color_manual(values = colOffs) +
geom_smooth(method = "lm", col="black")+
scale_x_continuous("Number of cytosines covered") +
scale_y_continuous("Residuals of number of methylated cytosines\n on number of cytosines covered") +
theme_bw() + ggtitle(label = "Offspring, CpG shared by half fish/trt")
fullMetadata_OFFS_half$res_Nbr_methCpG_Nbr_coveredCpG_div1000 <- (fullMetadata_OFFS_half$res_Nbr_methCpG_Nbr_coveredCpG)/1000
mod_Tol.Meth <- lmer(BCI ~ res_Nbr_methCpG_Nbr_coveredCpG_div1000*No.Worms + (1|brotherPairID)+ (1|Sex),
data=fullMetadata_OFFS_half, REML = F)
## Model selection:
step(mod_Tol.Meth, reduce.random = F) # Model found: BCI ~ No.Worms + (1 | brotherPairID) + (1 | Sex)
plot(ggpredict(mod_Tol.Meth, terms = c("res_Nbr_methCpG_Nbr_coveredCpG_div1000", "No.Worms")))+ theme_bw() +
ylab("Body Condition Index") + xlab("Global methylation") +
ggtitle("Predicted values of Body Condition Index in offspring")
## And by treatment instead of No.worms?
mod_Tol.Meth2 <- lmer(BCI ~ res_Nbr_methCpG_Nbr_coveredCpG_div1000*PAT*outcome + (1|brotherPairID)+ (1|Sex),
data=fullMetadata_OFFS_half, REML = F)
plot(ggpredict(mod_Tol.Meth2, terms = c("res_Nbr_methCpG_Nbr_coveredCpG_div1000","PAT", "outcome")), add.data=T)+
scale_color_manual(values = colOffs)
mod_Tol.Meth <- lmer(BCI ~ res_Nbr_methCpG_Nbr_coveredCpG_div1000*No.Worms*PAT + (1|brotherPairID)+ (1|Sex),
data=fullMetadata_OFFS_half, REML = F)
## Model selection:
step(mod_Tol.Meth, reduce.random = F) # Model found: BCI ~ No.Worms + (1 | brotherPairID) + (1 | Sex)
plot(ggpredict(mod_Tol.Meth, terms = c("res_Nbr_methCpG_Nbr_coveredCpG_div1000", "No.Worms", "PAT")))+ theme_bw() +
ylab("Body Condition Index") + xlab("Global methylation") +
ggtitle("Predicted values of Body Condition Index in offspring")
plot(ggpredict(mod_Tol.Meth, terms = c("res_Nbr_methCpG_Nbr_coveredCpG_div1000", "PAT", "No.Worms")))+ theme_bw() +
ylab("Body Condition Index") + xlab("Global methylation") +
ggtitle("Predicted values of Body Condition Index in offspring")
plot(ggpredict(mod_Tol.Meth, terms = c("PAT", "No.Worms")))+ theme_bw() +
ylab("Body Condition Index") + xlab("Global methylation") +
ggtitle("Predicted values of Body Condition Index in offspring")
plot(ggpredict(mod_Tol.Meth, terms = c("No.Worms", "PAT")))+ theme_bw() +
ylab("Body Condition Index") + xlab("Global methylation") +
ggtitle("Predicted values of Body Condition Index in offspring")
plot(ggpredict(mod_Tol.Meth, terms = c("No.Worms", "PAT")))+ theme_bw() +
ylab("Body Condition Index") + xlab("Global methylation") +
ggtitle("Predicted values of Body Condition Index in offspring")+
scale_color_manual(values = colOffs)
plot(ggpredict(mod_Tol.Meth, terms = c("No.Worms", "PAT")))+ theme_bw() +
ylab("Body Condition Index") + xlab("Global methylation") +
ggtitle("Predicted values of Body Condition Index in offspring")+
scale_color_manual(values = c("black", "red"))
plot(ggpredict(mod_Tol.Meth, terms = c("No.Worms", "PAT")), add.data=T)+ theme_bw() +
ylab("Body Condition Index") + xlab("Global methylation") +
ggtitle("Predicted values of Body Condition Index in offspring")+
scale_color_manual(values = c("black", "red"))
plot(ggpredict(mod_Tol.Meth, terms = c("No.Worms", "PAT")), add.data=T)+ theme_bw() +
ylab("Body Condition Index") + #xlab("Global methylation") +
ggtitle("Predicted values of Body Condition Index in offspring")+
scale_color_manual(values = c("black", "red"))
plot(ggpredict(mod_Tol.Meth, terms = c("No.Worms", "PAT")), add.data=T)+ theme_bw() +
ylab("Body Condition Index") + xlab("Number of worms") +
ggtitle("Predicted values of Body Condition Index in offspring")+
scale_color_manual(values = c("black", "red"))
## Plot
ggplot(fullMetadata_OFFS_half, aes(trtG1G2, res_Nbr_methCpG_Nbr_coveredCpG,
group=interaction(trtG1G2, Sex))) +
facet_grid(~Sex) +
geom_violin() +
geom_boxplot(aes(fill = trtG1G2), width = 0.2) +
geom_jitter(width = .1, size = 1, pch = 21, fill = "white") +
scale_fill_manual(values = colOffs) +
ylab("Global methylation")+
theme_bw() + theme(legend.position = "none")
## Plot
ggplot(fullMetadata_OFFS_half, aes(trtG1G2, res_Nbr_methCpG_Nbr_coveredCpG,
group=interaction(trtG1G2, Sex))) +
facet_grid(~Sex) +
geom_violin() +
geom_boxplot(aes(fill = trtG1G2), width = 0.2) +
geom_jitter(width = .1, size = 1, pch = 21, fill = "white") +
scale_fill_manual(values = colOffs) +
ylab("Global methylation")+ xlab(NULL)+
theme_bw() + theme(legend.position = "none")
modFinal <- lmer(res_Nbr_methCpG_Nbr_coveredCpG ~ Sex + (1|brotherPairID),
data = fullMetadata_OFFS_half, REML = F) # REML =F for model comparison
## Plot
plot(ggpredict(modFinal, terms = c("Sex")), add.data=T)+ theme_bw() #+
## Plot
plot(ggpredict(modFinal, terms = c("Sex")), add.data=T)+ theme_bw() +
ylab("Global methylation") +
ggtitle("Predicted values of global methylation in offspring")
modTol1 <- lmer(BCI ~ PAT*outcome*No.Worms + (1|brotherPairID) + (1|Sex), data=fullMetadata_OFFS)
step(modTol1, reduce.random = F) # Model found: keep ALL
modTol1_noworms <- lmer(BCI ~ PAT*outcome + (1|brotherPairID) + (1|Sex), data=fullMetadata_OFFS)
modTol1_noPAT <- lmer(BCI ~ outcome*No.Worms + (1|brotherPairID) + (1|Sex), data=fullMetadata_OFFS)
modTol1_nooffsp <- lmer(BCI ~ PAT*No.Worms + (1|brotherPairID) + (1|Sex), data=fullMetadata_OFFS)
lrtest(modTol1, modTol1_noworms) # chi2 11.375  p= 0.003387 **
lrtest(modTol1, modTol1_noPAT) # chi2 41.717  p=4.608e-09 ***
lrtest(modTol1, modTol1_nooffsp) # chi2 24.308  p=5.268e-06 ***
modTol1 <- lmer(BCI ~ PAT*outcome*No.Worms + (1|brotherPairID) + (1|Sex), data=fullMetadata_OFFS)
step(modTol1, reduce.random = F) # Model found: keep ALL
fullMetadata_OFFS_half$res_Nbr_methCpG_Nbr_coveredCpG_div1000 <- (fullMetadata_OFFS_half$res_Nbr_methCpG_Nbr_coveredCpG)/1000
mod_Tol.Meth <- lmer(BCI ~ res_Nbr_methCpG_Nbr_coveredCpG_div1000*No.Worms*PAT + (1|brotherPairID)+ (1|Sex),
data=fullMetadata_OFFS_half, REML = F)
## Model selection:
step(mod_Tol.Meth, reduce.random = F) # Model found: BCI ~ No.Worms + PAT + (1 | brotherPairID) + (1 | Sex) + No.Worms:PAT
plot(ggpredict(mod_Tol.Meth, terms = c("No.Worms", "PAT")), add.data=T)+ theme_bw() +
ylab("Body Condition Index") + xlab("Number of worms") +
ggtitle("Predicted values of Body Condition Index in offspring")+
scale_color_manual(values = c("black", "red"))
plot(ggpredict(mod_Tol.Meth, terms = c("No.Worms", "PAT")), add.data=T)+ theme_bw() +
ylab("Body Condition Index") + xlab("Number of worms") +
ggtitle("Predicted values of Body Condition Index in offspring")+
scale_color_manual(NULL, values = c("black", "red"))
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
fullMetadata_OFFS_half
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE,
message = FALSE, cache.lazy = FALSE, cache.path = "../../gitignore/RmdCache/", # keep heavy data in gitignore cache
fig.path = "Rfigures/Rmd/")
machine="mythinkpad" # define the machine we work on
loadALL = FALSE # only load CpG shared by half fish per trt group
loadannot = TRUE # load genome annotations
sourceDMS = TRUE # Load the calculated DMS
source("R02.3_DATALOAD.R")
## Features Annotation (use package genomation v1.24.0)
## NB Promoters are defined by options at genomation::readTranscriptFeatures function.
## The default option is to take -1000,+1000bp around the TSS and you can change that.
## -> following Heckwolf 2020 and Sagonas 2020, we consider 1500bp upstream and 500 bp downstream
## Parents comparison:
diffAnn_PAR = annotateWithGeneParts(as(DMSlist$DMS_15pc_G1_C_T,"GRanges"),annotBed12)
## Offspring from control parents comparison:
diffAnn_G2_controlG1 = annotateWithGeneParts(as(DMSlist$DMS_15pc_CC_CT,"GRanges"),annotBed12)
## Offspring from infected parents comparison:
diffAnn_G2_infectedG1 = annotateWithGeneParts(as(DMSlist$DMS_15pc_TC_TT,"GRanges"),annotBed12)
par(mfrow=c(1,3))
par(mar = c(.1,0.1,5,0.1)) # Set the margin on all sides to 2
## Parents comparison:
diffAnn_PAR = annotateWithGeneParts(as(DMSlist$DMS_15pc_G1_C_T,"GRanges"),annotBed12)
diffAnn_PAR
genomation::plotTargetAnnotation(diffAnn_PAR,precedence=TRUE, main="DMS G1", cex.legend = 1, border="white")
## Offspring from control parents comparison:
diffAnn_G2_controlG1 = annotateWithGeneParts(as(DMSlist$DMS_15pc_CC_CT,"GRanges"),annotBed12)
diffAnn_G2_controlG1
genomation::plotTargetAnnotation(diffAnn_G2_controlG1,precedence=TRUE, main="DMS G2-G1c", cex.legend = 1, border="white")
## Offspring from infected parents comparison:
diffAnn_G2_infectedG1 = annotateWithGeneParts(as(DMSlist$DMS_15pc_TC_TT,"GRanges"),annotBed12)
diffAnn_G2_infectedG1
genomation::plotTargetAnnotation(diffAnn_G2_infectedG1,precedence=TRUE, main="DMS G2-G1i", cex.legend = 1, border="white")
par(mfrow=c(1,1))
## Run the function to get DMS info
DMS_info_G1 <- myDMSinfo(DMSlist$DMS_15pc_G1_C_T, uniteCov6_G1_woSexAndUnknowChrOVERLAP)
DMS_info_G2_G1c_final <- myDMSinfo(DMSlist$DMS_15pc_CC_CT, uniteCov14_G2_woSexAndUnknowChrOVERLAP)
DMS_info_G2_G1i_final <- myDMSinfo(DMSlist$DMS_15pc_TC_TT,uniteCov14_G2_woSexAndUnknowChrOVERLAP)
## Chi2 test: are the number of DMS from G2-G1C and G2-G1I overlapping with DMSpar statistically different?
A=length(intersect(DMS_info_G1$DMS,DMS_info_G2_G1c_final$DMS))
B=length(DMS_info_G2_G1c_final$DMS)
C=length(intersect(DMS_info_G1$DMS,DMS_info_G2_G1i_final$DMS))
D=length(DMS_info_G2_G1i_final$DMS)
Observed=matrix(c(A, B-A, C, D-C),nrow=2)
Observed
chisq.test(Observed)
## not statistically different
## output Venn diagrams
allVenn <- ggVennDiagram(list("DMS G1" = DMS_info_G1$DMS, "DMS G2-c" = DMS_info_G2_G1c_final$DMS, "DMS G2-i" = DMS_info_G2_G1i_final$DMS), label_alpha = 0) +
scale_fill_gradient(low="white",high = "red")
hypoVenn <- ggVennDiagram(list("DMS G1\nhypo" = DMS_info_G1$DMS[DMS_info_G1$direction %in% "hypo"],
"DMS G2-c\nhypo" = DMS_info_G2_G1c_final$DMS[DMS_info_G2_G1c_final$direction %in% "hypo"],
"DMS G2-i\nhypo" = DMS_info_G2_G1i_final$DMS[DMS_info_G2_G1i_final$direction %in% "hypo"]), label_alpha = 0) +
scale_fill_gradient(low="white",high = "red")
hyperVenn <- ggVennDiagram(list("DMS G1\nhyper" = DMS_info_G1$DMS[DMS_info_G1$direction %in% "hyper"],
"DMS G2-c\nhyper" = DMS_info_G2_G1c_final$DMS[DMS_info_G2_G1c_final$direction %in% "hyper"],
"DMS G2-i\nhyper" = DMS_info_G2_G1i_final$DMS[DMS_info_G2_G1i_final$direction %in% "hyper"]), label_alpha = 0) +
scale_fill_gradient(low="white",high = "red")
ggarrange(allVenn,
ggarrange(hypoVenn, hyperVenn, ncol = 2, legend = "none"),
nrow = 2, widths = c(.5,1))
runHyperHypoAnnot <- function(){
par(mfrow=c(2,3))
par(mar = c(.1,0.1,5,0.1)) # Set the margin on all sides to 2
####### HYPO
## Parents comparison:
A = annotateWithGeneParts(
as(DMSlist$DMS_15pc_G1_C_T[DMS_info_G1$direction %in% "hypo",],"GRanges"),annotBed12)
genomation::plotTargetAnnotation(A,precedence=TRUE, main="DMS G1\nhypo",
cex.legend = .4, border="white")
## Offspring from control parents comparison:
B = annotateWithGeneParts(
as(DMSlist$DMS_15pc_CC_CT[DMS_info_G2_G1c_final$direction %in% "hypo",],"GRanges"),annotBed12)
genomation::plotTargetAnnotation(B,precedence=TRUE, main="DMS G2-G1c\nhypo",
cex.legend = .4, border="white")
## Offspring from infected parents comparison:
C = annotateWithGeneParts(
as(DMSlist$DMS_15pc_TC_TT[DMS_info_G2_G1i_final$direction %in% "hypo",],"GRanges"),annotBed12)
genomation::plotTargetAnnotation(C,precedence=TRUE, main="DMS G2-G1i\nhypo",
cex.legend = .4, border="white")
####### HYPER
## Parents comparison:
D = annotateWithGeneParts(
as(DMSlist$DMS_15pc_G1_C_T[DMS_info_G1$direction %in% "hyper",],"GRanges"),annotBed12)
genomation::plotTargetAnnotation(D,precedence=TRUE, main="DMS G1\nhyper",
cex.legend = .4, border="white")
## Offspring from control parents comparison:
E = annotateWithGeneParts(
as(DMSlist$DMS_15pc_CC_CT[DMS_info_G2_G1c_final$direction %in% "hyper",],"GRanges"),annotBed12)
genomation::plotTargetAnnotation(E,precedence=TRUE, main="DMS G2-G1c\nhyper",
cex.legend = .4, border="white")
## Offspring from infected parents comparison:
f = annotateWithGeneParts(
as(DMSlist$DMS_15pc_TC_TT[DMS_info_G2_G1i_final$direction %in% "hyper",],"GRanges"),annotBed12)
genomation::plotTargetAnnotation(f,precedence=TRUE, main="DMS G2-G1i\nhyper",
cex.legend = .4, border="white")
par(mfrow=c(1,1))
return(list(G1hypo=A, G2G1chypo=B, G2G1ihypo=C, G1hyper=D, G2G1chyper=E, G2G1ihyper=f))
}
myannot=runHyperHypoAnnot()
############################################################
## Venn diagram of overlapping features by their annotation:
table(rowSums(as.data.frame(myannot$G1hypo@members))) # NB: some positions are labelled with several features!
## as in MBE 2021: "giving precedence to the following order promoters, exons,
## introns, and intergenic regions when features overlapped"
myAnnotateDMS <- function(DMS, annot){
## sanity check
if (nrow(DMS) != nrow(annot)){"STOP error in arguments"}
DMS$pos <- paste(DMS$chr, DMS$start, DMS$end)
## NB as in MBE 2021: "giving precedence to the following order promoters, exons,
## introns, and intergenic regions when features overlapped"
DMS$feature <- NA
## 1. promoters
DMS$feature[which(annot$prom == 1)] = "promoter"
## 2. exons
DMS$feature[which(annot$exon == 1 & annot$prom ==0)] = "exon"
## 3. intron
DMS$feature[which(annot$intro == 1 & annot$exon == 0 & annot$prom ==0)] = "intron"
## 4. intergenic regions
DMS$feature[which(annot$intro == 0 & annot$exon == 0 & annot$prom ==0)] = "intergenic"
return(DMS)
}
DMSlist$DMS_15pc_G1_C_T = myAnnotateDMS(DMSlist$DMS_15pc_G1_C_T, as.data.frame(diffAnn_PAR@members))
DMSlist$DMS_15pc_G1_C_T_HYPO = myAnnotateDMS(DMSlist$DMS_15pc_G1_C_T[DMS_info_G1$direction %in% "hypo",],
as.data.frame(myannot$G1hypo@members))
DMSlist$DMS_15pc_G1_C_T_HYPER = myAnnotateDMS(DMSlist$DMS_15pc_G1_C_T[DMS_info_G1$direction %in% "hyper",],
as.data.frame(myannot$G1hyper@members))
DMSlist$DMS_15pc_CC_CT = myAnnotateDMS(DMSlist$DMS_15pc_CC_CT, as.data.frame(diffAnn_G2_controlG1@members))
DMSlist$DMS_15pc_CC_CT_HYPO = myAnnotateDMS(DMSlist$DMS_15pc_CC_CT[DMS_info_G2_G1c_final$direction %in% "hypo",],
as.data.frame(myannot$G2G1chypo@members))
DMSlist$DMS_15pc_CC_CT_HYPER = myAnnotateDMS(DMSlist$DMS_15pc_CC_CT[DMS_info_G2_G1c_final$direction %in% "hyper",],
as.data.frame(myannot$G2G1chyper@members))
DMSlist$DMS_15pc_TC_TT = myAnnotateDMS(DMSlist$DMS_15pc_TC_TT, as.data.frame(diffAnn_G2_infectedG1@members))
DMSlist$DMS_15pc_TC_TT_HYPO = myAnnotateDMS(DMSlist$DMS_15pc_TC_TT[DMS_info_G2_G1i_final$direction %in% "hypo",],
as.data.frame(myannot$G2G1ihypo@members))
DMSlist$DMS_15pc_TC_TT_HYPER = myAnnotateDMS(DMSlist$DMS_15pc_TC_TT[DMS_info_G2_G1i_final$direction %in% "hyper",],
as.data.frame(myannot$G2G1ihyper@members))
## Make Venn diagram for each feature
getFeatureDFHYPO <- function(myfeat){
a = DMSlist$DMS_15pc_G1_C_T_HYPO$pos[DMSlist$DMS_15pc_G1_C_T_HYPO$feature %in% myfeat]
b = DMSlist$DMS_15pc_CC_CT_HYPO$pos[DMSlist$DMS_15pc_CC_CT_HYPO$feature %in% myfeat]
c = DMSlist$DMS_15pc_TC_TT_HYPO$pos[DMSlist$DMS_15pc_TC_TT_HYPO$feature %in% myfeat]
return(list(a=a,b=b,c=c))
}
getFeatureDFHYPER <- function(myfeat){
a = DMSlist$DMS_15pc_G1_C_T_HYPER$pos[DMSlist$DMS_15pc_G1_C_T_HYPER$feature %in% myfeat]
b = DMSlist$DMS_15pc_CC_CT_HYPER$pos[DMSlist$DMS_15pc_CC_CT_HYPER$feature %in% myfeat]
c = DMSlist$DMS_15pc_TC_TT_HYPER$pos[DMSlist$DMS_15pc_TC_TT_HYPER$feature %in% myfeat]
return(list(a=a,b=b,c=c))
}
getVenn <- function(feat, direction){
if (direction == "hypo"){
ggVennDiagram(list(A = getFeatureDFHYPO(feat)[["a"]],
B = getFeatureDFHYPO(feat)[["b"]],
C = getFeatureDFHYPO(feat)[["c"]]), label_alpha = 0,
category.names = c(paste0("DMS G1\nhypo\n", feat), paste0("DMS G2-c\nhypo\n", feat), paste0("DMS G2-i\nhypo\n", feat))) +
scale_fill_gradient(low="white",high = "red")
} else if (direction == "hyper"){
ggVennDiagram(list(A = getFeatureDFHYPER(feat)[["a"]],
B = getFeatureDFHYPER(feat)[["b"]],
C = getFeatureDFHYPER(feat)[["c"]]), label_alpha = 0,
category.names = c(paste0("DMS G1\nhyper\n", feat), paste0("DMS G2-c\nhyper\n", feat), paste0("DMS G2-i\nhyper\n", feat))) +
scale_fill_gradient(low="white",high = "red")
}
}
ggarrange(getVenn("promoter", "hypo"), getVenn("exon", "hypo"),
getVenn("intron", "hypo"), getVenn("intergenic", "hypo"),
nrow = 2, ncol = 2)
ggarrange(getVenn("promoter", "hyper"), getVenn("exon", "hyper"),
getVenn("intron", "hyper"), getVenn("intergenic", "hyper"),
nrow = 2, ncol = 2)
## Parents trt-ctrl
# load annotation
annot_PAR <- as.data.frame(diffAnn_PAR@members)
makeManhattanPlots(DMSfile = DMSlist$DMS_15pc_G1_C_T, annotFile = annot_PAR, GYgynogff = GYgynogff,
mycols = c("red", "grey", "black", "green"), mytitle = "Manhattan plot of G1 DMS")
## G2-G1c trt-ctrl
# load annotation
annot_G2_G1c <- as.data.frame(diffAnn_G2_controlG1@members)
makeManhattanPlots(DMSfile = DMSlist$DMS_15pc_CC_CT, annotFile = annot_G2_G1c, GYgynogff = GYgynogff,
mycols = c("red", "grey", "black", "green"), mytitle = "Manhattan plot of G2-G1c DMS")
## G2-G1i trt-ctrl
# load annotation
annot_G2_G1i <- as.data.frame(diffAnn_G2_infectedG1@members)
makeManhattanPlots(DMSfile = DMSlist$DMS_15pc_TC_TT, annotFile = annot_G2_G1i, GYgynogff = GYgynogff,
mycols = c("red", "grey", "black", "green"), mytitle = "Manhattan plot of G2-G1i DMS")
## Outliers in Manhattan plot: 15% diff + 2SD
outliers_G1_final <- which(abs(DMSlist$DMS_15pc_G1_C_T$meth.diff) > 15 + 2*sd(abs(DMSlist$DMS_15pc_G1_C_T$meth.diff)))
outliers_annot_G1 <- as.data.frame(diffAnn_PAR@members)[outliers_G1_final,]
makeManhattanPlots(DMSfile = DMSlist$DMS_15pc_G1_C_T[outliers_G1_final, ],
annotFile = outliers_annot_G1, GYgynogff = GYgynogff,
mycols = c("red", "grey", "black", "green"), mytitle = "Manhattan plot of G1 DMS")
outliers_G2_G1c_final <- which(abs(DMSlist$DMS_15pc_CC_CT$meth.diff) > 15 + 2*sd(abs(DMSlist$DMS_15pc_CC_CT$meth.diff)))
outliers_annot_G2_G1c <- as.data.frame(diffAnn_G2_controlG1@members)[outliers_G2_G1c_final,]
makeManhattanPlots(DMSfile = DMSlist$DMS_15pc_CC_CT[outliers_G2_G1c_final, ],
annotFile = outliers_annot_G2_G1c, GYgynogff = GYgynogff,
mycols = c("red", "grey", "black", "green"), mytitle = "Manhattan plot of G2-G1c DMS")
outliers_G2_G1i_final <- which(abs(DMSlist$DMS_15pc_TC_TT$meth.diff) > 15 + 2*sd(abs(DMSlist$DMS_15pc_TC_TT$meth.diff)))
outliers_annot_G2_G1i <- as.data.frame(diffAnn_G2_infectedG1@members)[outliers_G2_G1i_final,]
makeManhattanPlots(DMSfile = DMSlist$DMS_15pc_TC_TT[outliers_G2_G1i_final, ],
annotFile = outliers_annot_G2_G1i, GYgynogff = GYgynogff,
mycols = c("red", "grey", "black", "green"), mytitle = "Manhattan plot of G2-G1i DMS")
## All in DMSBPlist
#
# ## Add fam to bp
# names(DMSBPlist) <- paste0(plyr::join(data.frame(BP = names(DMSBPlist)),
#                                       unique(data.frame(BP = fullMetadata_OFFS$brotherPairID,
#                                                         fam = fullMetadata_OFFS$Family)))[[2]], "_", names(DMSBPlist))
## Extract DMS (by position)
myPosList = lapply(DMSBPlist, lapply, function(x){paste(x$chr, x$end)})
## Find DMS present in at least 4 BP out of 8 (half):
get2keep = function(Compa){
x <- lapply(myPosList, function(x){unlist(x[[paste0("DMS_15pc_BP_", Compa)]])})
f <- table(unlist((x))) # each DMS present between 1 and 8 times
tokeep <- names(f)[f >= 4]
print(length(tokeep))
## Keep the DMS present in 4 families minimum
DMSBPlist_INTER4 <- lapply(x, function(x){x[x %in% tokeep]})
## Reorder by family:
DMSBPlist_INTER4 <- DMSBPlist_INTER4[names(DMSBPlist_INTER4)[order(names(DMSBPlist_INTER4))]]
return(DMSBPlist_INTER4)
}
## Prepare df for complexUpset
getUpsetDF = function(i){ # for a given comparison
A = get2keep(vecCompa[i])
A2 = lapply(A, function(x){
x = data.frame(x)    # vector of DMS as df
names(x) = "DMS"    # name each CpG
return(x)
})
## Add BP name
for (i in 1:length(names(A2))){
A2[[i]]["BP"] = names(A2)[i]
}
# make a dataframe
A2 = A2 %>% reduce(full_join, by = "DMS")
# names column with BP id
for (i in 2:ncol(A2)) {names(A2)[i] = unique(A2[!is.na(A2[i]), i])}
# replace by 0 or 1 the DMS absence/presence
A = data.frame(apply(A2[2:9], 2, function(x) ifelse(is.na(x), 0, 1)))
# add DMS
A$DMS = A2$DMS
return(A)
}
## Vector of all 4 comparisons
vecCompa <- c("CC_TC", "CT_TT", "CC_CT", "TC_TT")
## Make upset plots
for (i in 1:4){
df = getUpsetDF(i)
print(ComplexUpset::upset(
df,
names(df)[1:8],
width_ratio=0.1,
sort_intersections_by=c('degree', 'cardinality'),
queries=query_by_degree(
df,  names(df)[1:8],
params_by_degree=list(
'1'=list(color='red', fill='red'),
'2'=list(color='purple', fill='purple'),
'3'=list(color='blue', fill='blue'),
'4'=list(color='grey', fill='grey'),
'5'=list(color='red', fill='red'),
'6'=list(color='purple', fill='purple'),
'7'=list(color='blue', fill='blue'),
'8'=list(color='green', fill='green')
),
only_components=c("intersections_matrix", "Intersection size")
)))
}
uniteCov14_G1bothTrt_G2control_woSexAndUnknowChr
sourceSubUnite = TRUE
source("R02.3_DATALOAD.R")
uniteCov14_G1bothTrt_G2control_woSexAndUnknowChr
uniteCov14_G1bothTrt_G2control_woSexAndUnknowChr
head(uniteCov14_G1bothTrt_G2control_woSexAndUnknowChr)
View(uniteCov14_G1bothTrt_G2control_woSexAndUnknowChr)
head(uniteCov14_G1bothTrt_G2control_woSexAndUnknowChr)
head(uniteCov14_G1bothTrt_G2control_woSexAndUnknowChr@sample.ids)
percMethylation(head(uniteCov14_G1bothTrt_G2control_woSexAndUnknowChr))
i = 1
get2keep(vecCompa[i])
myPosList
DMSvec = unique(unlist(get2keep(vecCompa[i])))
DMSvec
head(uniteCov14_G1bothTrt_G2control_woSexAndUnknowChr)
uniteCov14_G1bothTrt_G2control_woSexAndUnknowChr$chr
paste(uniteCov14_G1bothTrt_G2control_woSexAndUnknowChr$chr, uniteCov14_G1bothTrt_G2control_woSexAndUnknowChr$start)
paste(uniteCov14_G1bothTrt_G2control_woSexAndUnknowChr$chr, uniteCov14_G1bothTrt_G2control_woSexAndUnknowChr$start) %in% DMSvec
table(paste(uniteCov14_G1bothTrt_G2control_woSexAndUnknowChr$chr, uniteCov14_G1bothTrt_G2control_woSexAndUnknowChr$start) %in% DMSvec)
vecCompa
DMSvec = unique(unlist(get2keep(vecCompa["CC_TC"])))
subunite = uniteCov14_G1bothTrt_G2control_woSexAndUnknowChr
DMSvec = unique(unlist(get2keep(vecCompa["CC_TC"])))
table(paste(subunite$chr, subunite$start) %in% DMSvec)
DMSvec = unique(unlist(get2keep(vecCompa[[trt]])))
trt = "CC_TC"
subunite = uniteCov14_G1bothTrt_G2control_woSexAndUnknowChr
DMSvec = unique(unlist(get2keep(vecCompa[[trt]])))
vecCompa[trt]
vecCompa
DMSvec = unique(unlist(get2keep(vecCompa[i])))
i=1
subunite = uniteCov14_G1bothTrt_G2control_woSexAndUnknowChr
DMSvec = unique(unlist(get2keep(vecCompa[i])))
table(paste(subunite$chr, subunite$start) %in% DMSvec)
which(paste(subunite$chr, subunite$start) %in% DMSvec)
pos = which(paste(subunite$chr, subunite$start) %in% DMSvec)
methylKit::select(subunite, pos)
subuniteDMS = methylKit::select(subunite, pos)
# sanity check
length(subuniteDMS)
# sanity check
nrow(subuniteDMS)
length(DMSvec)
# sanity check
nrow(subuniteDMS) == length(DMSvec)
# Calculate residuals of methylation
percMethMat = methylKit::percMethylation(subuniteDMS
)
percMethMat
# create a dataframe with all info
percMethDF = data.frame(SampleID = colnames(percMethMat),
Nbr_methCpG = colSums(percMethMat>=70 & !is.na(percMethMat)), ## number of methylated sites
Nbr_coveredCpG = colSums(!is.na(percMethMat)))## number of sites covered in this sample
percMethDF
